//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 Php.g 2013-10-04 16:49:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


    using Code2Xml.Core.Antlr;
    using System;
    using System.Text;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  Code2Xml.Languages.ANTLRv3.Processors.Php 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
public partial class PhpLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int Abstract=4;
	public const int AccessModifier=5;
	public const int Ampersand=6;
	public const int And=7;
	public const int Apply=8;
	public const int Array=9;
	public const int ArrayAssign=10;
	public const int AsignmentOperator=11;
	public const int Asterisk=12;
	public const int Bang=13;
	public const int Block=14;
	public const int BodyString=15;
	public const int BodyStringRest=16;
	public const int BodyStringRestShortTag=17;
	public const int Boolean=18;
	public const int Break=19;
	public const int Case=20;
	public const int Cast=21;
	public const int Class=22;
	public const int ClassDefinition=23;
	public const int ClassMember=24;
	public const int Clone=25;
	public const int CloseCurlyBracket=26;
	public const int CloseRoundBracket=27;
	public const int CloseSquareBracket=28;
	public const int Colon=29;
	public const int Comma=30;
	public const int ComparisionOperator=31;
	public const int Const=32;
	public const int Continue=33;
	public const int DNum=34;
	public const int Decimal=35;
	public const int Default=36;
	public const int Digits=37;
	public const int Do=38;
	public const int Dollar=39;
	public const int Dot=40;
	public const int DoubleQuotedString=41;
	public const int Echo=42;
	public const int Else=43;
	public const int ElseIf=44;
	public const int Empty=45;
	public const int Eol=46;
	public const int EqualityOperator=47;
	public const int Equals=48;
	public const int EscapeCharector=49;
	public const int Exponent_DNum=50;
	public const int Extends=51;
	public const int Field=52;
	public const int For=53;
	public const int ForCondition=54;
	public const int ForInit=55;
	public const int ForUpdate=56;
	public const int Foreach=57;
	public const int Forwardslash=58;
	public const int Function=59;
	public const int Global=60;
	public const int HereDoc=61;
	public const int HereDocContents=62;
	public const int Hexadecimal=63;
	public const int If=64;
	public const int IfExpression=65;
	public const int Implements=66;
	public const int IncrementOperator=67;
	public const int InstanceMember=68;
	public const int Instanceof=69;
	public const int Integer=70;
	public const int Interface=71;
	public const int Label=72;
	public const int List=73;
	public const int LogicalAnd=74;
	public const int LogicalOr=75;
	public const int Member=76;
	public const int Method=77;
	public const int Minus=78;
	public const int Modifiers=79;
	public const int MultilineComment=80;
	public const int New=81;
	public const int Octal=82;
	public const int OpenCurlyBracket=83;
	public const int OpenRoundBracket=84;
	public const int OpenSquareBracket=85;
	public const int Or=86;
	public const int Params=87;
	public const int Percent=88;
	public const int Pipe=89;
	public const int Plus=90;
	public const int Postfix=91;
	public const int Prefix=92;
	public const int PrimitiveType=93;
	public const int QuestionMark=94;
	public const int Real=95;
	public const int Reference=96;
	public const int RequireOperator=97;
	public const int Return=98;
	public const int SemiColon=99;
	public const int ShiftOperator=100;
	public const int SingleQuotedString=101;
	public const int SinglelineComment=102;
	public const int Static=103;
	public const int SuppressWarnings=104;
	public const int Switch=105;
	public const int Tilde=106;
	public const int UnixComment=107;
	public const int UnquotedString=108;
	public const int Var=109;
	public const int While=110;
	public const int WhiteSpace=111;
	public const int Xor=112;
	public const int T__113=113;

	    protected const int HIDDEN = Hidden;
	    private bool allowShortOpenTag = false;

	    // Handle the first token, which will always be a BodyString.
	    public IToken nextToken(){
	        //The following code was pulled out from super.nextToken()
	        if (input.index() == 0) {
	            try {
	                state.token = null;
	                state.channel = DefaultTokenChannel;
	                state.tokenStartCharIndex = input.index();
	                state.tokenStartCharPositionInLine = input.getCharPositionInLine();
	                state.tokenStartLine = input.getLine();
	                state.text = null;
	                state.backtracking = 0;
	                mBodyStringRest();
	                state.type = BodyString;
	                Emit();
	                return state.token;
	            } catch (NoViableAltException nva) {
	                ReportError(nva);
	                Recover(nva); // throw out current char and try again
	            } catch (RecognitionException re) {
	                ReportError(re);
	                // match() routine has already called recover()
	            }
	        }
	        return base.NextToken();
	    }

	    /**
	     * Property to enable short open tags
	     * 
	     * Returns true if short open tags are enabled
	     * false if short open tags are disabled.
	     * 
	     */
	    public boolean isAllowShortOpenTag(){
	        return allowShortOpenTag;
	    }

	    /**
	     * Property to enable short open tags.
	     *
	     * Set to true to enable short open tags and false 
	     * to disable.
	     */
	    public void setAllowShortOpenTag(boolean val){
	        allowShortOpenTag = val;
	    }


	// delegates
	// delegators

	public PhpLexer()
	{
		OnCreated();
	}

	public PhpLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public PhpLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Php.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_Abstract();
	partial void LeaveRule_Abstract();

	// $ANTLR start "Abstract"
	[GrammarRule("Abstract")]
	private void mAbstract()
	{
		EnterRule_Abstract();
		EnterRule("Abstract", 1);
		TraceIn("Abstract", 1);
		try
		{
			int _type = Abstract;
			int _channel = DefaultTokenChannel;
			// Php.g:66:10: ( 'abstract' )
			DebugEnterAlt(1);
			// Php.g:66:12: 'abstract'
			{
			DebugLocation(66, 12);
			Match("abstract"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Abstract", 1);
			LeaveRule("Abstract", 1);
			LeaveRule_Abstract();
		}
	}
	// $ANTLR end "Abstract"

	partial void EnterRule_Ampersand();
	partial void LeaveRule_Ampersand();

	// $ANTLR start "Ampersand"
	[GrammarRule("Ampersand")]
	private void mAmpersand()
	{
		EnterRule_Ampersand();
		EnterRule("Ampersand", 2);
		TraceIn("Ampersand", 2);
		try
		{
			int _type = Ampersand;
			int _channel = DefaultTokenChannel;
			// Php.g:67:11: ( '&' )
			DebugEnterAlt(1);
			// Php.g:67:13: '&'
			{
			DebugLocation(67, 13);
			Match('&'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Ampersand", 2);
			LeaveRule("Ampersand", 2);
			LeaveRule_Ampersand();
		}
	}
	// $ANTLR end "Ampersand"

	partial void EnterRule_And();
	partial void LeaveRule_And();

	// $ANTLR start "And"
	[GrammarRule("And")]
	private void mAnd()
	{
		EnterRule_And();
		EnterRule("And", 3);
		TraceIn("And", 3);
		try
		{
			int _type = And;
			int _channel = DefaultTokenChannel;
			// Php.g:68:5: ( 'and' )
			DebugEnterAlt(1);
			// Php.g:68:7: 'and'
			{
			DebugLocation(68, 7);
			Match("and"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("And", 3);
			LeaveRule("And", 3);
			LeaveRule_And();
		}
	}
	// $ANTLR end "And"

	partial void EnterRule_ArrayAssign();
	partial void LeaveRule_ArrayAssign();

	// $ANTLR start "ArrayAssign"
	[GrammarRule("ArrayAssign")]
	private void mArrayAssign()
	{
		EnterRule_ArrayAssign();
		EnterRule("ArrayAssign", 4);
		TraceIn("ArrayAssign", 4);
		try
		{
			int _type = ArrayAssign;
			int _channel = DefaultTokenChannel;
			// Php.g:69:13: ( '=>' )
			DebugEnterAlt(1);
			// Php.g:69:15: '=>'
			{
			DebugLocation(69, 15);
			Match("=>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ArrayAssign", 4);
			LeaveRule("ArrayAssign", 4);
			LeaveRule_ArrayAssign();
		}
	}
	// $ANTLR end "ArrayAssign"

	partial void EnterRule_Asterisk();
	partial void LeaveRule_Asterisk();

	// $ANTLR start "Asterisk"
	[GrammarRule("Asterisk")]
	private void mAsterisk()
	{
		EnterRule_Asterisk();
		EnterRule("Asterisk", 5);
		TraceIn("Asterisk", 5);
		try
		{
			int _type = Asterisk;
			int _channel = DefaultTokenChannel;
			// Php.g:70:10: ( '*' )
			DebugEnterAlt(1);
			// Php.g:70:12: '*'
			{
			DebugLocation(70, 12);
			Match('*'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Asterisk", 5);
			LeaveRule("Asterisk", 5);
			LeaveRule_Asterisk();
		}
	}
	// $ANTLR end "Asterisk"

	partial void EnterRule_Bang();
	partial void LeaveRule_Bang();

	// $ANTLR start "Bang"
	[GrammarRule("Bang")]
	private void mBang()
	{
		EnterRule_Bang();
		EnterRule("Bang", 6);
		TraceIn("Bang", 6);
		try
		{
			int _type = Bang;
			int _channel = DefaultTokenChannel;
			// Php.g:71:6: ( '!' )
			DebugEnterAlt(1);
			// Php.g:71:8: '!'
			{
			DebugLocation(71, 8);
			Match('!'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Bang", 6);
			LeaveRule("Bang", 6);
			LeaveRule_Bang();
		}
	}
	// $ANTLR end "Bang"

	partial void EnterRule_Break();
	partial void LeaveRule_Break();

	// $ANTLR start "Break"
	[GrammarRule("Break")]
	private void mBreak()
	{
		EnterRule_Break();
		EnterRule("Break", 7);
		TraceIn("Break", 7);
		try
		{
			int _type = Break;
			int _channel = DefaultTokenChannel;
			// Php.g:72:7: ( 'break' )
			DebugEnterAlt(1);
			// Php.g:72:9: 'break'
			{
			DebugLocation(72, 9);
			Match("break"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Break", 7);
			LeaveRule("Break", 7);
			LeaveRule_Break();
		}
	}
	// $ANTLR end "Break"

	partial void EnterRule_Case();
	partial void LeaveRule_Case();

	// $ANTLR start "Case"
	[GrammarRule("Case")]
	private void mCase()
	{
		EnterRule_Case();
		EnterRule("Case", 8);
		TraceIn("Case", 8);
		try
		{
			int _type = Case;
			int _channel = DefaultTokenChannel;
			// Php.g:73:6: ( 'case' )
			DebugEnterAlt(1);
			// Php.g:73:8: 'case'
			{
			DebugLocation(73, 8);
			Match("case"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Case", 8);
			LeaveRule("Case", 8);
			LeaveRule_Case();
		}
	}
	// $ANTLR end "Case"

	partial void EnterRule_Class();
	partial void LeaveRule_Class();

	// $ANTLR start "Class"
	[GrammarRule("Class")]
	private void mClass()
	{
		EnterRule_Class();
		EnterRule("Class", 9);
		TraceIn("Class", 9);
		try
		{
			int _type = Class;
			int _channel = DefaultTokenChannel;
			// Php.g:74:7: ( 'class' )
			DebugEnterAlt(1);
			// Php.g:74:9: 'class'
			{
			DebugLocation(74, 9);
			Match("class"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Class", 9);
			LeaveRule("Class", 9);
			LeaveRule_Class();
		}
	}
	// $ANTLR end "Class"

	partial void EnterRule_ClassMember();
	partial void LeaveRule_ClassMember();

	// $ANTLR start "ClassMember"
	[GrammarRule("ClassMember")]
	private void mClassMember()
	{
		EnterRule_ClassMember();
		EnterRule("ClassMember", 10);
		TraceIn("ClassMember", 10);
		try
		{
			int _type = ClassMember;
			int _channel = DefaultTokenChannel;
			// Php.g:75:13: ( '::' )
			DebugEnterAlt(1);
			// Php.g:75:15: '::'
			{
			DebugLocation(75, 15);
			Match("::"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ClassMember", 10);
			LeaveRule("ClassMember", 10);
			LeaveRule_ClassMember();
		}
	}
	// $ANTLR end "ClassMember"

	partial void EnterRule_Clone();
	partial void LeaveRule_Clone();

	// $ANTLR start "Clone"
	[GrammarRule("Clone")]
	private void mClone()
	{
		EnterRule_Clone();
		EnterRule("Clone", 11);
		TraceIn("Clone", 11);
		try
		{
			int _type = Clone;
			int _channel = DefaultTokenChannel;
			// Php.g:76:7: ( 'clone' )
			DebugEnterAlt(1);
			// Php.g:76:9: 'clone'
			{
			DebugLocation(76, 9);
			Match("clone"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Clone", 11);
			LeaveRule("Clone", 11);
			LeaveRule_Clone();
		}
	}
	// $ANTLR end "Clone"

	partial void EnterRule_CloseCurlyBracket();
	partial void LeaveRule_CloseCurlyBracket();

	// $ANTLR start "CloseCurlyBracket"
	[GrammarRule("CloseCurlyBracket")]
	private void mCloseCurlyBracket()
	{
		EnterRule_CloseCurlyBracket();
		EnterRule("CloseCurlyBracket", 12);
		TraceIn("CloseCurlyBracket", 12);
		try
		{
			int _type = CloseCurlyBracket;
			int _channel = DefaultTokenChannel;
			// Php.g:77:19: ( '}' )
			DebugEnterAlt(1);
			// Php.g:77:21: '}'
			{
			DebugLocation(77, 21);
			Match('}'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CloseCurlyBracket", 12);
			LeaveRule("CloseCurlyBracket", 12);
			LeaveRule_CloseCurlyBracket();
		}
	}
	// $ANTLR end "CloseCurlyBracket"

	partial void EnterRule_CloseRoundBracket();
	partial void LeaveRule_CloseRoundBracket();

	// $ANTLR start "CloseRoundBracket"
	[GrammarRule("CloseRoundBracket")]
	private void mCloseRoundBracket()
	{
		EnterRule_CloseRoundBracket();
		EnterRule("CloseRoundBracket", 13);
		TraceIn("CloseRoundBracket", 13);
		try
		{
			int _type = CloseRoundBracket;
			int _channel = DefaultTokenChannel;
			// Php.g:78:19: ( ')' )
			DebugEnterAlt(1);
			// Php.g:78:21: ')'
			{
			DebugLocation(78, 21);
			Match(')'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CloseRoundBracket", 13);
			LeaveRule("CloseRoundBracket", 13);
			LeaveRule_CloseRoundBracket();
		}
	}
	// $ANTLR end "CloseRoundBracket"

	partial void EnterRule_CloseSquareBracket();
	partial void LeaveRule_CloseSquareBracket();

	// $ANTLR start "CloseSquareBracket"
	[GrammarRule("CloseSquareBracket")]
	private void mCloseSquareBracket()
	{
		EnterRule_CloseSquareBracket();
		EnterRule("CloseSquareBracket", 14);
		TraceIn("CloseSquareBracket", 14);
		try
		{
			int _type = CloseSquareBracket;
			int _channel = DefaultTokenChannel;
			// Php.g:79:20: ( ']' )
			DebugEnterAlt(1);
			// Php.g:79:22: ']'
			{
			DebugLocation(79, 22);
			Match(']'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CloseSquareBracket", 14);
			LeaveRule("CloseSquareBracket", 14);
			LeaveRule_CloseSquareBracket();
		}
	}
	// $ANTLR end "CloseSquareBracket"

	partial void EnterRule_Colon();
	partial void LeaveRule_Colon();

	// $ANTLR start "Colon"
	[GrammarRule("Colon")]
	private void mColon()
	{
		EnterRule_Colon();
		EnterRule("Colon", 15);
		TraceIn("Colon", 15);
		try
		{
			int _type = Colon;
			int _channel = DefaultTokenChannel;
			// Php.g:80:7: ( ':' )
			DebugEnterAlt(1);
			// Php.g:80:9: ':'
			{
			DebugLocation(80, 9);
			Match(':'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Colon", 15);
			LeaveRule("Colon", 15);
			LeaveRule_Colon();
		}
	}
	// $ANTLR end "Colon"

	partial void EnterRule_Comma();
	partial void LeaveRule_Comma();

	// $ANTLR start "Comma"
	[GrammarRule("Comma")]
	private void mComma()
	{
		EnterRule_Comma();
		EnterRule("Comma", 16);
		TraceIn("Comma", 16);
		try
		{
			int _type = Comma;
			int _channel = DefaultTokenChannel;
			// Php.g:81:7: ( ',' )
			DebugEnterAlt(1);
			// Php.g:81:9: ','
			{
			DebugLocation(81, 9);
			Match(','); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Comma", 16);
			LeaveRule("Comma", 16);
			LeaveRule_Comma();
		}
	}
	// $ANTLR end "Comma"

	partial void EnterRule_Const();
	partial void LeaveRule_Const();

	// $ANTLR start "Const"
	[GrammarRule("Const")]
	private void mConst()
	{
		EnterRule_Const();
		EnterRule("Const", 17);
		TraceIn("Const", 17);
		try
		{
			int _type = Const;
			int _channel = DefaultTokenChannel;
			// Php.g:82:7: ( 'const' )
			DebugEnterAlt(1);
			// Php.g:82:9: 'const'
			{
			DebugLocation(82, 9);
			Match("const"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Const", 17);
			LeaveRule("Const", 17);
			LeaveRule_Const();
		}
	}
	// $ANTLR end "Const"

	partial void EnterRule_Continue();
	partial void LeaveRule_Continue();

	// $ANTLR start "Continue"
	[GrammarRule("Continue")]
	private void mContinue()
	{
		EnterRule_Continue();
		EnterRule("Continue", 18);
		TraceIn("Continue", 18);
		try
		{
			int _type = Continue;
			int _channel = DefaultTokenChannel;
			// Php.g:83:10: ( 'continue' )
			DebugEnterAlt(1);
			// Php.g:83:12: 'continue'
			{
			DebugLocation(83, 12);
			Match("continue"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Continue", 18);
			LeaveRule("Continue", 18);
			LeaveRule_Continue();
		}
	}
	// $ANTLR end "Continue"

	partial void EnterRule_Default();
	partial void LeaveRule_Default();

	// $ANTLR start "Default"
	[GrammarRule("Default")]
	private void mDefault()
	{
		EnterRule_Default();
		EnterRule("Default", 19);
		TraceIn("Default", 19);
		try
		{
			int _type = Default;
			int _channel = DefaultTokenChannel;
			// Php.g:84:9: ( 'default' )
			DebugEnterAlt(1);
			// Php.g:84:11: 'default'
			{
			DebugLocation(84, 11);
			Match("default"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Default", 19);
			LeaveRule("Default", 19);
			LeaveRule_Default();
		}
	}
	// $ANTLR end "Default"

	partial void EnterRule_Do();
	partial void LeaveRule_Do();

	// $ANTLR start "Do"
	[GrammarRule("Do")]
	private void mDo()
	{
		EnterRule_Do();
		EnterRule("Do", 20);
		TraceIn("Do", 20);
		try
		{
			int _type = Do;
			int _channel = DefaultTokenChannel;
			// Php.g:85:4: ( 'do' )
			DebugEnterAlt(1);
			// Php.g:85:6: 'do'
			{
			DebugLocation(85, 6);
			Match("do"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Do", 20);
			LeaveRule("Do", 20);
			LeaveRule_Do();
		}
	}
	// $ANTLR end "Do"

	partial void EnterRule_Dollar();
	partial void LeaveRule_Dollar();

	// $ANTLR start "Dollar"
	[GrammarRule("Dollar")]
	private void mDollar()
	{
		EnterRule_Dollar();
		EnterRule("Dollar", 21);
		TraceIn("Dollar", 21);
		try
		{
			int _type = Dollar;
			int _channel = DefaultTokenChannel;
			// Php.g:86:8: ( '$' )
			DebugEnterAlt(1);
			// Php.g:86:10: '$'
			{
			DebugLocation(86, 10);
			Match('$'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Dollar", 21);
			LeaveRule("Dollar", 21);
			LeaveRule_Dollar();
		}
	}
	// $ANTLR end "Dollar"

	partial void EnterRule_Dot();
	partial void LeaveRule_Dot();

	// $ANTLR start "Dot"
	[GrammarRule("Dot")]
	private void mDot()
	{
		EnterRule_Dot();
		EnterRule("Dot", 22);
		TraceIn("Dot", 22);
		try
		{
			int _type = Dot;
			int _channel = DefaultTokenChannel;
			// Php.g:87:5: ( '.' )
			DebugEnterAlt(1);
			// Php.g:87:7: '.'
			{
			DebugLocation(87, 7);
			Match('.'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Dot", 22);
			LeaveRule("Dot", 22);
			LeaveRule_Dot();
		}
	}
	// $ANTLR end "Dot"

	partial void EnterRule_Echo();
	partial void LeaveRule_Echo();

	// $ANTLR start "Echo"
	[GrammarRule("Echo")]
	private void mEcho()
	{
		EnterRule_Echo();
		EnterRule("Echo", 23);
		TraceIn("Echo", 23);
		try
		{
			int _type = Echo;
			int _channel = DefaultTokenChannel;
			// Php.g:88:6: ( 'echo' )
			DebugEnterAlt(1);
			// Php.g:88:8: 'echo'
			{
			DebugLocation(88, 8);
			Match("echo"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Echo", 23);
			LeaveRule("Echo", 23);
			LeaveRule_Echo();
		}
	}
	// $ANTLR end "Echo"

	partial void EnterRule_Else();
	partial void LeaveRule_Else();

	// $ANTLR start "Else"
	[GrammarRule("Else")]
	private void mElse()
	{
		EnterRule_Else();
		EnterRule("Else", 24);
		TraceIn("Else", 24);
		try
		{
			int _type = Else;
			int _channel = DefaultTokenChannel;
			// Php.g:89:6: ( 'else' )
			DebugEnterAlt(1);
			// Php.g:89:8: 'else'
			{
			DebugLocation(89, 8);
			Match("else"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Else", 24);
			LeaveRule("Else", 24);
			LeaveRule_Else();
		}
	}
	// $ANTLR end "Else"

	partial void EnterRule_ElseIf();
	partial void LeaveRule_ElseIf();

	// $ANTLR start "ElseIf"
	[GrammarRule("ElseIf")]
	private void mElseIf()
	{
		EnterRule_ElseIf();
		EnterRule("ElseIf", 25);
		TraceIn("ElseIf", 25);
		try
		{
			int _type = ElseIf;
			int _channel = DefaultTokenChannel;
			// Php.g:90:8: ( 'elseif' )
			DebugEnterAlt(1);
			// Php.g:90:10: 'elseif'
			{
			DebugLocation(90, 10);
			Match("elseif"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ElseIf", 25);
			LeaveRule("ElseIf", 25);
			LeaveRule_ElseIf();
		}
	}
	// $ANTLR end "ElseIf"

	partial void EnterRule_Equals();
	partial void LeaveRule_Equals();

	// $ANTLR start "Equals"
	[GrammarRule("Equals")]
	private void mEquals()
	{
		EnterRule_Equals();
		EnterRule("Equals", 26);
		TraceIn("Equals", 26);
		try
		{
			int _type = Equals;
			int _channel = DefaultTokenChannel;
			// Php.g:91:8: ( '=' )
			DebugEnterAlt(1);
			// Php.g:91:10: '='
			{
			DebugLocation(91, 10);
			Match('='); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Equals", 26);
			LeaveRule("Equals", 26);
			LeaveRule_Equals();
		}
	}
	// $ANTLR end "Equals"

	partial void EnterRule_Extends();
	partial void LeaveRule_Extends();

	// $ANTLR start "Extends"
	[GrammarRule("Extends")]
	private void mExtends()
	{
		EnterRule_Extends();
		EnterRule("Extends", 27);
		TraceIn("Extends", 27);
		try
		{
			int _type = Extends;
			int _channel = DefaultTokenChannel;
			// Php.g:92:9: ( 'extends' )
			DebugEnterAlt(1);
			// Php.g:92:11: 'extends'
			{
			DebugLocation(92, 11);
			Match("extends"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Extends", 27);
			LeaveRule("Extends", 27);
			LeaveRule_Extends();
		}
	}
	// $ANTLR end "Extends"

	partial void EnterRule_For();
	partial void LeaveRule_For();

	// $ANTLR start "For"
	[GrammarRule("For")]
	private void mFor()
	{
		EnterRule_For();
		EnterRule("For", 28);
		TraceIn("For", 28);
		try
		{
			int _type = For;
			int _channel = DefaultTokenChannel;
			// Php.g:93:5: ( 'for' )
			DebugEnterAlt(1);
			// Php.g:93:7: 'for'
			{
			DebugLocation(93, 7);
			Match("for"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("For", 28);
			LeaveRule("For", 28);
			LeaveRule_For();
		}
	}
	// $ANTLR end "For"

	partial void EnterRule_Foreach();
	partial void LeaveRule_Foreach();

	// $ANTLR start "Foreach"
	[GrammarRule("Foreach")]
	private void mForeach()
	{
		EnterRule_Foreach();
		EnterRule("Foreach", 29);
		TraceIn("Foreach", 29);
		try
		{
			int _type = Foreach;
			int _channel = DefaultTokenChannel;
			// Php.g:94:9: ( 'foreach' )
			DebugEnterAlt(1);
			// Php.g:94:11: 'foreach'
			{
			DebugLocation(94, 11);
			Match("foreach"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Foreach", 29);
			LeaveRule("Foreach", 29);
			LeaveRule_Foreach();
		}
	}
	// $ANTLR end "Foreach"

	partial void EnterRule_Forwardslash();
	partial void LeaveRule_Forwardslash();

	// $ANTLR start "Forwardslash"
	[GrammarRule("Forwardslash")]
	private void mForwardslash()
	{
		EnterRule_Forwardslash();
		EnterRule("Forwardslash", 30);
		TraceIn("Forwardslash", 30);
		try
		{
			int _type = Forwardslash;
			int _channel = DefaultTokenChannel;
			// Php.g:95:14: ( '/' )
			DebugEnterAlt(1);
			// Php.g:95:16: '/'
			{
			DebugLocation(95, 16);
			Match('/'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Forwardslash", 30);
			LeaveRule("Forwardslash", 30);
			LeaveRule_Forwardslash();
		}
	}
	// $ANTLR end "Forwardslash"

	partial void EnterRule_Function();
	partial void LeaveRule_Function();

	// $ANTLR start "Function"
	[GrammarRule("Function")]
	private void mFunction()
	{
		EnterRule_Function();
		EnterRule("Function", 31);
		TraceIn("Function", 31);
		try
		{
			int _type = Function;
			int _channel = DefaultTokenChannel;
			// Php.g:96:10: ( 'function' )
			DebugEnterAlt(1);
			// Php.g:96:12: 'function'
			{
			DebugLocation(96, 12);
			Match("function"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Function", 31);
			LeaveRule("Function", 31);
			LeaveRule_Function();
		}
	}
	// $ANTLR end "Function"

	partial void EnterRule_Global();
	partial void LeaveRule_Global();

	// $ANTLR start "Global"
	[GrammarRule("Global")]
	private void mGlobal()
	{
		EnterRule_Global();
		EnterRule("Global", 32);
		TraceIn("Global", 32);
		try
		{
			int _type = Global;
			int _channel = DefaultTokenChannel;
			// Php.g:97:8: ( 'global' )
			DebugEnterAlt(1);
			// Php.g:97:10: 'global'
			{
			DebugLocation(97, 10);
			Match("global"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Global", 32);
			LeaveRule("Global", 32);
			LeaveRule_Global();
		}
	}
	// $ANTLR end "Global"

	partial void EnterRule_If();
	partial void LeaveRule_If();

	// $ANTLR start "If"
	[GrammarRule("If")]
	private void mIf()
	{
		EnterRule_If();
		EnterRule("If", 33);
		TraceIn("If", 33);
		try
		{
			int _type = If;
			int _channel = DefaultTokenChannel;
			// Php.g:98:4: ( 'if' )
			DebugEnterAlt(1);
			// Php.g:98:6: 'if'
			{
			DebugLocation(98, 6);
			Match("if"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("If", 33);
			LeaveRule("If", 33);
			LeaveRule_If();
		}
	}
	// $ANTLR end "If"

	partial void EnterRule_Implements();
	partial void LeaveRule_Implements();

	// $ANTLR start "Implements"
	[GrammarRule("Implements")]
	private void mImplements()
	{
		EnterRule_Implements();
		EnterRule("Implements", 34);
		TraceIn("Implements", 34);
		try
		{
			int _type = Implements;
			int _channel = DefaultTokenChannel;
			// Php.g:99:12: ( 'implements' )
			DebugEnterAlt(1);
			// Php.g:99:14: 'implements'
			{
			DebugLocation(99, 14);
			Match("implements"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Implements", 34);
			LeaveRule("Implements", 34);
			LeaveRule_Implements();
		}
	}
	// $ANTLR end "Implements"

	partial void EnterRule_InstanceMember();
	partial void LeaveRule_InstanceMember();

	// $ANTLR start "InstanceMember"
	[GrammarRule("InstanceMember")]
	private void mInstanceMember()
	{
		EnterRule_InstanceMember();
		EnterRule("InstanceMember", 35);
		TraceIn("InstanceMember", 35);
		try
		{
			int _type = InstanceMember;
			int _channel = DefaultTokenChannel;
			// Php.g:100:16: ( '->' )
			DebugEnterAlt(1);
			// Php.g:100:18: '->'
			{
			DebugLocation(100, 18);
			Match("->"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("InstanceMember", 35);
			LeaveRule("InstanceMember", 35);
			LeaveRule_InstanceMember();
		}
	}
	// $ANTLR end "InstanceMember"

	partial void EnterRule_Instanceof();
	partial void LeaveRule_Instanceof();

	// $ANTLR start "Instanceof"
	[GrammarRule("Instanceof")]
	private void mInstanceof()
	{
		EnterRule_Instanceof();
		EnterRule("Instanceof", 36);
		TraceIn("Instanceof", 36);
		try
		{
			int _type = Instanceof;
			int _channel = DefaultTokenChannel;
			// Php.g:101:12: ( 'instanceof' )
			DebugEnterAlt(1);
			// Php.g:101:14: 'instanceof'
			{
			DebugLocation(101, 14);
			Match("instanceof"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Instanceof", 36);
			LeaveRule("Instanceof", 36);
			LeaveRule_Instanceof();
		}
	}
	// $ANTLR end "Instanceof"

	partial void EnterRule_Interface();
	partial void LeaveRule_Interface();

	// $ANTLR start "Interface"
	[GrammarRule("Interface")]
	private void mInterface()
	{
		EnterRule_Interface();
		EnterRule("Interface", 37);
		TraceIn("Interface", 37);
		try
		{
			int _type = Interface;
			int _channel = DefaultTokenChannel;
			// Php.g:102:11: ( 'interface' )
			DebugEnterAlt(1);
			// Php.g:102:13: 'interface'
			{
			DebugLocation(102, 13);
			Match("interface"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Interface", 37);
			LeaveRule("Interface", 37);
			LeaveRule_Interface();
		}
	}
	// $ANTLR end "Interface"

	partial void EnterRule_List();
	partial void LeaveRule_List();

	// $ANTLR start "List"
	[GrammarRule("List")]
	private void mList()
	{
		EnterRule_List();
		EnterRule("List", 38);
		TraceIn("List", 38);
		try
		{
			int _type = List;
			int _channel = DefaultTokenChannel;
			// Php.g:103:6: ( 'list' )
			DebugEnterAlt(1);
			// Php.g:103:8: 'list'
			{
			DebugLocation(103, 8);
			Match("list"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("List", 38);
			LeaveRule("List", 38);
			LeaveRule_List();
		}
	}
	// $ANTLR end "List"

	partial void EnterRule_LogicalAnd();
	partial void LeaveRule_LogicalAnd();

	// $ANTLR start "LogicalAnd"
	[GrammarRule("LogicalAnd")]
	private void mLogicalAnd()
	{
		EnterRule_LogicalAnd();
		EnterRule("LogicalAnd", 39);
		TraceIn("LogicalAnd", 39);
		try
		{
			int _type = LogicalAnd;
			int _channel = DefaultTokenChannel;
			// Php.g:104:12: ( '&&' )
			DebugEnterAlt(1);
			// Php.g:104:14: '&&'
			{
			DebugLocation(104, 14);
			Match("&&"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LogicalAnd", 39);
			LeaveRule("LogicalAnd", 39);
			LeaveRule_LogicalAnd();
		}
	}
	// $ANTLR end "LogicalAnd"

	partial void EnterRule_LogicalOr();
	partial void LeaveRule_LogicalOr();

	// $ANTLR start "LogicalOr"
	[GrammarRule("LogicalOr")]
	private void mLogicalOr()
	{
		EnterRule_LogicalOr();
		EnterRule("LogicalOr", 40);
		TraceIn("LogicalOr", 40);
		try
		{
			int _type = LogicalOr;
			int _channel = DefaultTokenChannel;
			// Php.g:105:11: ( '||' )
			DebugEnterAlt(1);
			// Php.g:105:13: '||'
			{
			DebugLocation(105, 13);
			Match("||"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LogicalOr", 40);
			LeaveRule("LogicalOr", 40);
			LeaveRule_LogicalOr();
		}
	}
	// $ANTLR end "LogicalOr"

	partial void EnterRule_Minus();
	partial void LeaveRule_Minus();

	// $ANTLR start "Minus"
	[GrammarRule("Minus")]
	private void mMinus()
	{
		EnterRule_Minus();
		EnterRule("Minus", 41);
		TraceIn("Minus", 41);
		try
		{
			int _type = Minus;
			int _channel = DefaultTokenChannel;
			// Php.g:106:7: ( '-' )
			DebugEnterAlt(1);
			// Php.g:106:9: '-'
			{
			DebugLocation(106, 9);
			Match('-'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Minus", 41);
			LeaveRule("Minus", 41);
			LeaveRule_Minus();
		}
	}
	// $ANTLR end "Minus"

	partial void EnterRule_New();
	partial void LeaveRule_New();

	// $ANTLR start "New"
	[GrammarRule("New")]
	private void mNew()
	{
		EnterRule_New();
		EnterRule("New", 42);
		TraceIn("New", 42);
		try
		{
			int _type = New;
			int _channel = DefaultTokenChannel;
			// Php.g:107:5: ( 'new' )
			DebugEnterAlt(1);
			// Php.g:107:7: 'new'
			{
			DebugLocation(107, 7);
			Match("new"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("New", 42);
			LeaveRule("New", 42);
			LeaveRule_New();
		}
	}
	// $ANTLR end "New"

	partial void EnterRule_OpenCurlyBracket();
	partial void LeaveRule_OpenCurlyBracket();

	// $ANTLR start "OpenCurlyBracket"
	[GrammarRule("OpenCurlyBracket")]
	private void mOpenCurlyBracket()
	{
		EnterRule_OpenCurlyBracket();
		EnterRule("OpenCurlyBracket", 43);
		TraceIn("OpenCurlyBracket", 43);
		try
		{
			int _type = OpenCurlyBracket;
			int _channel = DefaultTokenChannel;
			// Php.g:108:18: ( '{' )
			DebugEnterAlt(1);
			// Php.g:108:20: '{'
			{
			DebugLocation(108, 20);
			Match('{'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OpenCurlyBracket", 43);
			LeaveRule("OpenCurlyBracket", 43);
			LeaveRule_OpenCurlyBracket();
		}
	}
	// $ANTLR end "OpenCurlyBracket"

	partial void EnterRule_OpenRoundBracket();
	partial void LeaveRule_OpenRoundBracket();

	// $ANTLR start "OpenRoundBracket"
	[GrammarRule("OpenRoundBracket")]
	private void mOpenRoundBracket()
	{
		EnterRule_OpenRoundBracket();
		EnterRule("OpenRoundBracket", 44);
		TraceIn("OpenRoundBracket", 44);
		try
		{
			int _type = OpenRoundBracket;
			int _channel = DefaultTokenChannel;
			// Php.g:109:18: ( '(' )
			DebugEnterAlt(1);
			// Php.g:109:20: '('
			{
			DebugLocation(109, 20);
			Match('('); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OpenRoundBracket", 44);
			LeaveRule("OpenRoundBracket", 44);
			LeaveRule_OpenRoundBracket();
		}
	}
	// $ANTLR end "OpenRoundBracket"

	partial void EnterRule_OpenSquareBracket();
	partial void LeaveRule_OpenSquareBracket();

	// $ANTLR start "OpenSquareBracket"
	[GrammarRule("OpenSquareBracket")]
	private void mOpenSquareBracket()
	{
		EnterRule_OpenSquareBracket();
		EnterRule("OpenSquareBracket", 45);
		TraceIn("OpenSquareBracket", 45);
		try
		{
			int _type = OpenSquareBracket;
			int _channel = DefaultTokenChannel;
			// Php.g:110:19: ( '[' )
			DebugEnterAlt(1);
			// Php.g:110:21: '['
			{
			DebugLocation(110, 21);
			Match('['); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OpenSquareBracket", 45);
			LeaveRule("OpenSquareBracket", 45);
			LeaveRule_OpenSquareBracket();
		}
	}
	// $ANTLR end "OpenSquareBracket"

	partial void EnterRule_Or();
	partial void LeaveRule_Or();

	// $ANTLR start "Or"
	[GrammarRule("Or")]
	private void mOr()
	{
		EnterRule_Or();
		EnterRule("Or", 46);
		TraceIn("Or", 46);
		try
		{
			int _type = Or;
			int _channel = DefaultTokenChannel;
			// Php.g:111:4: ( 'or' )
			DebugEnterAlt(1);
			// Php.g:111:6: 'or'
			{
			DebugLocation(111, 6);
			Match("or"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Or", 46);
			LeaveRule("Or", 46);
			LeaveRule_Or();
		}
	}
	// $ANTLR end "Or"

	partial void EnterRule_Percent();
	partial void LeaveRule_Percent();

	// $ANTLR start "Percent"
	[GrammarRule("Percent")]
	private void mPercent()
	{
		EnterRule_Percent();
		EnterRule("Percent", 47);
		TraceIn("Percent", 47);
		try
		{
			int _type = Percent;
			int _channel = DefaultTokenChannel;
			// Php.g:112:9: ( '%' )
			DebugEnterAlt(1);
			// Php.g:112:11: '%'
			{
			DebugLocation(112, 11);
			Match('%'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Percent", 47);
			LeaveRule("Percent", 47);
			LeaveRule_Percent();
		}
	}
	// $ANTLR end "Percent"

	partial void EnterRule_Pipe();
	partial void LeaveRule_Pipe();

	// $ANTLR start "Pipe"
	[GrammarRule("Pipe")]
	private void mPipe()
	{
		EnterRule_Pipe();
		EnterRule("Pipe", 48);
		TraceIn("Pipe", 48);
		try
		{
			int _type = Pipe;
			int _channel = DefaultTokenChannel;
			// Php.g:113:6: ( '|' )
			DebugEnterAlt(1);
			// Php.g:113:8: '|'
			{
			DebugLocation(113, 8);
			Match('|'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Pipe", 48);
			LeaveRule("Pipe", 48);
			LeaveRule_Pipe();
		}
	}
	// $ANTLR end "Pipe"

	partial void EnterRule_Plus();
	partial void LeaveRule_Plus();

	// $ANTLR start "Plus"
	[GrammarRule("Plus")]
	private void mPlus()
	{
		EnterRule_Plus();
		EnterRule("Plus", 49);
		TraceIn("Plus", 49);
		try
		{
			int _type = Plus;
			int _channel = DefaultTokenChannel;
			// Php.g:114:6: ( '+' )
			DebugEnterAlt(1);
			// Php.g:114:8: '+'
			{
			DebugLocation(114, 8);
			Match('+'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Plus", 49);
			LeaveRule("Plus", 49);
			LeaveRule_Plus();
		}
	}
	// $ANTLR end "Plus"

	partial void EnterRule_QuestionMark();
	partial void LeaveRule_QuestionMark();

	// $ANTLR start "QuestionMark"
	[GrammarRule("QuestionMark")]
	private void mQuestionMark()
	{
		EnterRule_QuestionMark();
		EnterRule("QuestionMark", 50);
		TraceIn("QuestionMark", 50);
		try
		{
			int _type = QuestionMark;
			int _channel = DefaultTokenChannel;
			// Php.g:115:14: ( '?' )
			DebugEnterAlt(1);
			// Php.g:115:16: '?'
			{
			DebugLocation(115, 16);
			Match('?'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("QuestionMark", 50);
			LeaveRule("QuestionMark", 50);
			LeaveRule_QuestionMark();
		}
	}
	// $ANTLR end "QuestionMark"

	partial void EnterRule_Return();
	partial void LeaveRule_Return();

	// $ANTLR start "Return"
	[GrammarRule("Return")]
	private void mReturn()
	{
		EnterRule_Return();
		EnterRule("Return", 51);
		TraceIn("Return", 51);
		try
		{
			int _type = Return;
			int _channel = DefaultTokenChannel;
			// Php.g:116:8: ( 'return' )
			DebugEnterAlt(1);
			// Php.g:116:10: 'return'
			{
			DebugLocation(116, 10);
			Match("return"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Return", 51);
			LeaveRule("Return", 51);
			LeaveRule_Return();
		}
	}
	// $ANTLR end "Return"

	partial void EnterRule_SemiColon();
	partial void LeaveRule_SemiColon();

	// $ANTLR start "SemiColon"
	[GrammarRule("SemiColon")]
	private void mSemiColon()
	{
		EnterRule_SemiColon();
		EnterRule("SemiColon", 52);
		TraceIn("SemiColon", 52);
		try
		{
			int _type = SemiColon;
			int _channel = DefaultTokenChannel;
			// Php.g:117:11: ( ';' )
			DebugEnterAlt(1);
			// Php.g:117:13: ';'
			{
			DebugLocation(117, 13);
			Match(';'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SemiColon", 52);
			LeaveRule("SemiColon", 52);
			LeaveRule_SemiColon();
		}
	}
	// $ANTLR end "SemiColon"

	partial void EnterRule_Static();
	partial void LeaveRule_Static();

	// $ANTLR start "Static"
	[GrammarRule("Static")]
	private void mStatic()
	{
		EnterRule_Static();
		EnterRule("Static", 53);
		TraceIn("Static", 53);
		try
		{
			int _type = Static;
			int _channel = DefaultTokenChannel;
			// Php.g:118:8: ( 'static' )
			DebugEnterAlt(1);
			// Php.g:118:10: 'static'
			{
			DebugLocation(118, 10);
			Match("static"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Static", 53);
			LeaveRule("Static", 53);
			LeaveRule_Static();
		}
	}
	// $ANTLR end "Static"

	partial void EnterRule_SuppressWarnings();
	partial void LeaveRule_SuppressWarnings();

	// $ANTLR start "SuppressWarnings"
	[GrammarRule("SuppressWarnings")]
	private void mSuppressWarnings()
	{
		EnterRule_SuppressWarnings();
		EnterRule("SuppressWarnings", 54);
		TraceIn("SuppressWarnings", 54);
		try
		{
			int _type = SuppressWarnings;
			int _channel = DefaultTokenChannel;
			// Php.g:119:18: ( '@' )
			DebugEnterAlt(1);
			// Php.g:119:20: '@'
			{
			DebugLocation(119, 20);
			Match('@'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SuppressWarnings", 54);
			LeaveRule("SuppressWarnings", 54);
			LeaveRule_SuppressWarnings();
		}
	}
	// $ANTLR end "SuppressWarnings"

	partial void EnterRule_Switch();
	partial void LeaveRule_Switch();

	// $ANTLR start "Switch"
	[GrammarRule("Switch")]
	private void mSwitch()
	{
		EnterRule_Switch();
		EnterRule("Switch", 55);
		TraceIn("Switch", 55);
		try
		{
			int _type = Switch;
			int _channel = DefaultTokenChannel;
			// Php.g:120:8: ( 'switch' )
			DebugEnterAlt(1);
			// Php.g:120:10: 'switch'
			{
			DebugLocation(120, 10);
			Match("switch"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Switch", 55);
			LeaveRule("Switch", 55);
			LeaveRule_Switch();
		}
	}
	// $ANTLR end "Switch"

	partial void EnterRule_Tilde();
	partial void LeaveRule_Tilde();

	// $ANTLR start "Tilde"
	[GrammarRule("Tilde")]
	private void mTilde()
	{
		EnterRule_Tilde();
		EnterRule("Tilde", 56);
		TraceIn("Tilde", 56);
		try
		{
			int _type = Tilde;
			int _channel = DefaultTokenChannel;
			// Php.g:121:7: ( '~' )
			DebugEnterAlt(1);
			// Php.g:121:9: '~'
			{
			DebugLocation(121, 9);
			Match('~'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Tilde", 56);
			LeaveRule("Tilde", 56);
			LeaveRule_Tilde();
		}
	}
	// $ANTLR end "Tilde"

	partial void EnterRule_Var();
	partial void LeaveRule_Var();

	// $ANTLR start "Var"
	[GrammarRule("Var")]
	private void mVar()
	{
		EnterRule_Var();
		EnterRule("Var", 57);
		TraceIn("Var", 57);
		try
		{
			int _type = Var;
			int _channel = DefaultTokenChannel;
			// Php.g:122:5: ( 'var' )
			DebugEnterAlt(1);
			// Php.g:122:7: 'var'
			{
			DebugLocation(122, 7);
			Match("var"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Var", 57);
			LeaveRule("Var", 57);
			LeaveRule_Var();
		}
	}
	// $ANTLR end "Var"

	partial void EnterRule_While();
	partial void LeaveRule_While();

	// $ANTLR start "While"
	[GrammarRule("While")]
	private void mWhile()
	{
		EnterRule_While();
		EnterRule("While", 58);
		TraceIn("While", 58);
		try
		{
			int _type = While;
			int _channel = DefaultTokenChannel;
			// Php.g:123:7: ( 'while' )
			DebugEnterAlt(1);
			// Php.g:123:9: 'while'
			{
			DebugLocation(123, 9);
			Match("while"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("While", 58);
			LeaveRule("While", 58);
			LeaveRule_While();
		}
	}
	// $ANTLR end "While"

	partial void EnterRule_Xor();
	partial void LeaveRule_Xor();

	// $ANTLR start "Xor"
	[GrammarRule("Xor")]
	private void mXor()
	{
		EnterRule_Xor();
		EnterRule("Xor", 59);
		TraceIn("Xor", 59);
		try
		{
			int _type = Xor;
			int _channel = DefaultTokenChannel;
			// Php.g:124:5: ( 'xor' )
			DebugEnterAlt(1);
			// Php.g:124:7: 'xor'
			{
			DebugLocation(124, 7);
			Match("xor"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Xor", 59);
			LeaveRule("Xor", 59);
			LeaveRule_Xor();
		}
	}
	// $ANTLR end "Xor"

	partial void EnterRule_T__113();
	partial void LeaveRule_T__113();

	// $ANTLR start "T__113"
	[GrammarRule("T__113")]
	private void mT__113()
	{
		EnterRule_T__113();
		EnterRule("T__113", 60);
		TraceIn("T__113", 60);
		try
		{
			int _type = T__113;
			int _channel = DefaultTokenChannel;
			// Php.g:125:8: ( 'as' )
			DebugEnterAlt(1);
			// Php.g:125:10: 'as'
			{
			DebugLocation(125, 10);
			Match("as"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__113", 60);
			LeaveRule("T__113", 60);
			LeaveRule_T__113();
		}
	}
	// $ANTLR end "T__113"

	partial void EnterRule_BodyString();
	partial void LeaveRule_BodyString();

	// $ANTLR start "BodyString"
	[GrammarRule("BodyString")]
	private void mBodyString()
	{
		EnterRule_BodyString();
		EnterRule("BodyString", 61);
		TraceIn("BodyString", 61);
		try
		{
			int _type = BodyString;
			int _channel = DefaultTokenChannel;
			// Php.g:471:5: ( '?>' BodyStringRest )
			DebugEnterAlt(1);
			// Php.g:471:7: '?>' BodyStringRest
			{
			DebugLocation(471, 7);
			Match("?>"); if (state.failed) return;

			DebugLocation(471, 12);
			mBodyStringRest(); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BodyString", 61);
			LeaveRule("BodyString", 61);
			LeaveRule_BodyString();
		}
	}
	// $ANTLR end "BodyString"

	partial void EnterRule_BodyStringRest();
	partial void LeaveRule_BodyStringRest();

	// $ANTLR start "BodyStringRest"
	[GrammarRule("BodyStringRest")]
	private void mBodyStringRest()
	{
		EnterRule_BodyStringRest();
		EnterRule("BodyStringRest", 62);
		TraceIn("BodyStringRest", 62);
		try
		{
			// Php.g:477:5: ({...}? => BodyStringRestShortTag | ( ( '<' ~ '?' )=> '<' |~ '<' )* ( '<?' ( 'php' | '=' ) )? )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1=='<'))
			{
				int LA4_2 = input.LA(2);

				if (((isAllowShortOpenTag())))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 4, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if (((LA4_1>='\u0000' && LA4_1<=';')||(LA4_1>='=' && LA4_1<='\uFFFF')))
			{
				int LA4_2 = input.LA(2);

				if (((isAllowShortOpenTag())))
				{
					alt4 = 1;
				}
				else if ((true))
				{
					alt4 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 4, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if (((isAllowShortOpenTag())))
			{
				alt4 = 1;
			}
			else if ((true))
			{
				alt4 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:477:7: {...}? => BodyStringRestShortTag
				{
				DebugLocation(477, 7);
				if (!((isAllowShortOpenTag())))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "BodyStringRest", "isAllowShortOpenTag()");
				}
				DebugLocation(477, 34);
				mBodyStringRestShortTag(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:478:7: ( ( '<' ~ '?' )=> '<' |~ '<' )* ( '<?' ( 'php' | '=' ) )?
				{
				DebugLocation(478, 7);
				// Php.g:478:7: ( ( '<' ~ '?' )=> '<' |~ '<' )*
				try { DebugEnterSubRule(1);
				while (true)
				{
					int alt1=3;
					try { DebugEnterDecision(1, false);
					int LA1_1 = input.LA(1);

					if ((LA1_1=='<'))
					{
						int LA1_2 = input.LA(2);

						if ((LA1_2=='?'))
						{
							int LA1_3 = input.LA(3);

							if ((LA1_3=='p'))
							{
								int LA1_4 = input.LA(4);

								if ((LA1_4=='h'))
								{
									int LA1_5 = input.LA(5);

									if ((LA1_5=='p'))
									{
										int LA1_6 = input.LA(6);

										if ((EvaluatePredicate(synpred1_Php_fragment)))
										{
											alt1 = 1;
										}


									}
									else if ((LA1_5=='<') && (EvaluatePredicate(synpred1_Php_fragment)))
									{
										alt1 = 1;
									}
									else if (((LA1_5>='\u0000' && LA1_5<=';')||(LA1_5>='=' && LA1_5<='o')||(LA1_5>='q' && LA1_5<='\uFFFF')) && (EvaluatePredicate(synpred1_Php_fragment)))
									{
										alt1 = 1;
									}

									else
									{
										alt1 = 1;
									}


								}
								else if ((LA1_4=='<') && (EvaluatePredicate(synpred1_Php_fragment)))
								{
									alt1 = 1;
								}
								else if (((LA1_4>='\u0000' && LA1_4<=';')||(LA1_4>='=' && LA1_4<='g')||(LA1_4>='i' && LA1_4<='\uFFFF')) && (EvaluatePredicate(synpred1_Php_fragment)))
								{
									alt1 = 1;
								}

								else
								{
									alt1 = 1;
								}


							}
							else if ((LA1_3=='='))
							{
								int LA1_4 = input.LA(4);

								if ((EvaluatePredicate(synpred1_Php_fragment)))
								{
									alt1 = 1;
								}


							}
							else if ((LA1_3=='<') && (EvaluatePredicate(synpred1_Php_fragment)))
							{
								alt1 = 1;
							}
							else if (((LA1_3>='\u0000' && LA1_3<=';')||(LA1_3>='>' && LA1_3<='o')||(LA1_3>='q' && LA1_3<='\uFFFF')) && (EvaluatePredicate(synpred1_Php_fragment)))
							{
								alt1 = 1;
							}

							else
							{
								alt1 = 1;
							}


						}
						else if ((LA1_2=='<') && (EvaluatePredicate(synpred1_Php_fragment)))
						{
							alt1 = 1;
						}
						else if (((LA1_2>='\u0000' && LA1_2<=';')||(LA1_2>='=' && LA1_2<='>')||(LA1_2>='@' && LA1_2<='\uFFFF')) && (EvaluatePredicate(synpred1_Php_fragment)))
						{
							alt1 = 1;
						}

						else
						{
							alt1 = 1;
						}


					}
					else if (((LA1_1>='\u0000' && LA1_1<=';')||(LA1_1>='=' && LA1_1<='\uFFFF')))
					{
						alt1 = 2;
					}


					} finally { DebugExitDecision(1); }
					switch ( alt1 )
					{
					case 1:
						DebugEnterAlt(1);
						// Php.g:478:8: ( '<' ~ '?' )=> '<'
						{
						DebugLocation(478, 22);
						Match('<'); if (state.failed) return;

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Php.g:478:28: ~ '<'
						{
						DebugLocation(478, 28);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop1;
					}
				}

				loop1:
					;

				} finally { DebugExitSubRule(1); }

				DebugLocation(478, 36);
				// Php.g:478:36: ( '<?' ( 'php' | '=' ) )?
				int alt3=2;
				try { DebugEnterSubRule(3);
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1=='<'))
				{
					alt3 = 1;
				}
				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:478:37: '<?' ( 'php' | '=' )
					{
					DebugLocation(478, 37);
					Match("<?"); if (state.failed) return;

					DebugLocation(478, 42);
					// Php.g:478:42: ( 'php' | '=' )
					int alt2=2;
					try { DebugEnterSubRule(2);
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if ((LA2_1=='p'))
					{
						alt2 = 1;
					}
					else if ((LA2_1=='='))
					{
						alt2 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 2, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// Php.g:478:43: 'php'
						{
						DebugLocation(478, 43);
						Match("php"); if (state.failed) return;


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// Php.g:478:49: '='
						{
						DebugLocation(478, 49);
						Match('='); if (state.failed) return;

						}
						break;

					}
					} finally { DebugExitSubRule(2); }


					}
					break;

				}
				} finally { DebugExitSubRule(3); }


				}
				break;

			}
		}
		finally
		{
			TraceOut("BodyStringRest", 62);
			LeaveRule("BodyStringRest", 62);
			LeaveRule_BodyStringRest();
		}
	}
	// $ANTLR end "BodyStringRest"

	partial void EnterRule_BodyStringRestShortTag();
	partial void LeaveRule_BodyStringRestShortTag();

	// $ANTLR start "BodyStringRestShortTag"
	[GrammarRule("BodyStringRestShortTag")]
	private void mBodyStringRestShortTag()
	{
		EnterRule_BodyStringRestShortTag();
		EnterRule("BodyStringRestShortTag", 63);
		TraceIn("BodyStringRestShortTag", 63);
		try
		{
			// Php.g:483:5: ( ( ( '<' ~ '?' )=> '<' |~ '<' )* ( '<?' ( 'php' | '=' )? )? )
			DebugEnterAlt(1);
			// Php.g:483:7: ( ( '<' ~ '?' )=> '<' |~ '<' )* ( '<?' ( 'php' | '=' )? )?
			{
			DebugLocation(483, 7);
			// Php.g:483:7: ( ( '<' ~ '?' )=> '<' |~ '<' )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=3;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1=='<'))
				{
					int LA5_2 = input.LA(2);

					if ((LA5_2=='?'))
					{
						int LA5_3 = input.LA(3);

						if ((EvaluatePredicate(synpred2_Php_fragment)))
						{
							alt5 = 1;
						}


					}
					else if ((LA5_2=='<') && (EvaluatePredicate(synpred2_Php_fragment)))
					{
						alt5 = 1;
					}
					else if (((LA5_2>='\u0000' && LA5_2<=';')||(LA5_2>='=' && LA5_2<='>')||(LA5_2>='@' && LA5_2<='\uFFFF')) && (EvaluatePredicate(synpred2_Php_fragment)))
					{
						alt5 = 1;
					}

					else
					{
						alt5 = 1;
					}


				}
				else if (((LA5_1>='\u0000' && LA5_1<=';')||(LA5_1>='=' && LA5_1<='\uFFFF')))
				{
					alt5 = 2;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:483:8: ( '<' ~ '?' )=> '<'
					{
					DebugLocation(483, 22);
					Match('<'); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Php.g:483:28: ~ '<'
					{
					DebugLocation(483, 28);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(483, 36);
			// Php.g:483:36: ( '<?' ( 'php' | '=' )? )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1=='<'))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:483:37: '<?' ( 'php' | '=' )?
				{
				DebugLocation(483, 37);
				Match("<?"); if (state.failed) return;

				DebugLocation(483, 42);
				// Php.g:483:42: ( 'php' | '=' )?
				int alt6=3;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1=='p'))
				{
					alt6 = 1;
				}
				else if ((LA6_1=='='))
				{
					alt6 = 2;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:483:43: 'php'
					{
					DebugLocation(483, 43);
					Match("php"); if (state.failed) return;


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Php.g:483:49: '='
					{
					DebugLocation(483, 49);
					Match('='); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(6); }


				}
				break;

			}
			} finally { DebugExitSubRule(7); }


			}

		}
		finally
		{
			TraceOut("BodyStringRestShortTag", 63);
			LeaveRule("BodyStringRestShortTag", 63);
			LeaveRule_BodyStringRestShortTag();
		}
	}
	// $ANTLR end "BodyStringRestShortTag"

	partial void EnterRule_MultilineComment();
	partial void LeaveRule_MultilineComment();

	// $ANTLR start "MultilineComment"
	[GrammarRule("MultilineComment")]
	private void mMultilineComment()
	{
		EnterRule_MultilineComment();
		EnterRule("MultilineComment", 64);
		TraceIn("MultilineComment", 64);
		try
		{
			int _type = MultilineComment;
			int _channel = DefaultTokenChannel;
			// Php.g:488:5: ( '/*' ( ( '*' ~ '/' )=> '*' |~ '*' )* '*/' )
			DebugEnterAlt(1);
			// Php.g:488:7: '/*' ( ( '*' ~ '/' )=> '*' |~ '*' )* '*/'
			{
			DebugLocation(488, 7);
			Match("/*"); if (state.failed) return;

			DebugLocation(488, 12);
			// Php.g:488:12: ( ( '*' ~ '/' )=> '*' |~ '*' )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=3;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1=='*'))
				{
					int LA8_2 = input.LA(2);

					if ((LA8_2=='/'))
					{
						int LA8_3 = input.LA(3);

						if ((LA8_3=='*') && (EvaluatePredicate(synpred3_Php_fragment)))
						{
							alt8 = 1;
						}
						else if (((LA8_3>='\u0000' && LA8_3<=')')||(LA8_3>='+' && LA8_3<='\uFFFF')) && (EvaluatePredicate(synpred3_Php_fragment)))
						{
							alt8 = 1;
						}


					}
					else if ((LA8_2=='*') && (EvaluatePredicate(synpred3_Php_fragment)))
					{
						alt8 = 1;
					}
					else if (((LA8_2>='\u0000' && LA8_2<=')')||(LA8_2>='+' && LA8_2<='.')||(LA8_2>='0' && LA8_2<='\uFFFF')) && (EvaluatePredicate(synpred3_Php_fragment)))
					{
						alt8 = 1;
					}


				}
				else if (((LA8_1>='\u0000' && LA8_1<=')')||(LA8_1>='+' && LA8_1<='\uFFFF')))
				{
					alt8 = 2;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:488:13: ( '*' ~ '/' )=> '*'
					{
					DebugLocation(488, 26);
					Match('*'); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Php.g:488:32: ~ '*'
					{
					DebugLocation(488, 32);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(488, 40);
			Match("*/"); if (state.failed) return;

			DebugLocation(488, 45);
			if (state.backtracking == 0)
			{
				_channel=HIDDEN;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MultilineComment", 64);
			LeaveRule("MultilineComment", 64);
			LeaveRule_MultilineComment();
		}
	}
	// $ANTLR end "MultilineComment"

	partial void EnterRule_SinglelineComment();
	partial void LeaveRule_SinglelineComment();

	// $ANTLR start "SinglelineComment"
	[GrammarRule("SinglelineComment")]
	private void mSinglelineComment()
	{
		EnterRule_SinglelineComment();
		EnterRule("SinglelineComment", 65);
		TraceIn("SinglelineComment", 65);
		try
		{
			int _type = SinglelineComment;
			int _channel = DefaultTokenChannel;
			// Php.g:492:5: ( '//' ( ( '?' ~ '>' )=> '?' |~ ( '\\n' | '?' ) )* )
			DebugEnterAlt(1);
			// Php.g:492:7: '//' ( ( '?' ~ '>' )=> '?' |~ ( '\\n' | '?' ) )*
			{
			DebugLocation(492, 7);
			Match("//"); if (state.failed) return;

			DebugLocation(492, 13);
			// Php.g:492:13: ( ( '?' ~ '>' )=> '?' |~ ( '\\n' | '?' ) )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=3;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1=='?') && (EvaluatePredicate(synpred4_Php_fragment)))
				{
					alt9 = 1;
				}
				else if (((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='>')||(LA9_1>='@' && LA9_1<='\uFFFF')))
				{
					alt9 = 2;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:492:14: ( '?' ~ '>' )=> '?'
					{
					DebugLocation(492, 26);
					Match('?'); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Php.g:492:32: ~ ( '\\n' | '?' )
					{
					DebugLocation(492, 32);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(492, 46);
			if (state.backtracking == 0)
			{
				_channel=HIDDEN;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SinglelineComment", 65);
			LeaveRule("SinglelineComment", 65);
			LeaveRule_SinglelineComment();
		}
	}
	// $ANTLR end "SinglelineComment"

	partial void EnterRule_UnixComment();
	partial void LeaveRule_UnixComment();

	// $ANTLR start "UnixComment"
	[GrammarRule("UnixComment")]
	private void mUnixComment()
	{
		EnterRule_UnixComment();
		EnterRule("UnixComment", 66);
		TraceIn("UnixComment", 66);
		try
		{
			int _type = UnixComment;
			int _channel = DefaultTokenChannel;
			// Php.g:496:5: ( '#' ( ( '?' ~ '>' )=> '?' |~ ( '\\n' | '?' ) )* )
			DebugEnterAlt(1);
			// Php.g:496:7: '#' ( ( '?' ~ '>' )=> '?' |~ ( '\\n' | '?' ) )*
			{
			DebugLocation(496, 7);
			Match('#'); if (state.failed) return;
			DebugLocation(496, 11);
			// Php.g:496:11: ( ( '?' ~ '>' )=> '?' |~ ( '\\n' | '?' ) )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=3;
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1=='?') && (EvaluatePredicate(synpred5_Php_fragment)))
				{
					alt10 = 1;
				}
				else if (((LA10_1>='\u0000' && LA10_1<='\t')||(LA10_1>='\u000B' && LA10_1<='>')||(LA10_1>='@' && LA10_1<='\uFFFF')))
				{
					alt10 = 2;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:496:12: ( '?' ~ '>' )=> '?'
					{
					DebugLocation(496, 24);
					Match('?'); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Php.g:496:30: ~ ( '\\n' | '?' )
					{
					DebugLocation(496, 30);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }

			DebugLocation(496, 44);
			if (state.backtracking == 0)
			{
				_channel=HIDDEN;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UnixComment", 66);
			LeaveRule("UnixComment", 66);
			LeaveRule_UnixComment();
		}
	}
	// $ANTLR end "UnixComment"

	partial void EnterRule_Array();
	partial void LeaveRule_Array();

	// $ANTLR start "Array"
	[GrammarRule("Array")]
	private void mArray()
	{
		EnterRule_Array();
		EnterRule("Array", 67);
		TraceIn("Array", 67);
		try
		{
			int _type = Array;
			int _channel = DefaultTokenChannel;
			// Php.g:501:5: ( ( 'a' | 'A' ) ( 'r' | 'R' ) ( 'r' | 'R' ) ( 'a' | 'A' ) ( 'y' | 'Y' ) )
			DebugEnterAlt(1);
			// Php.g:501:7: ( 'a' | 'A' ) ( 'r' | 'R' ) ( 'r' | 'R' ) ( 'a' | 'A' ) ( 'y' | 'Y' )
			{
			DebugLocation(501, 7);
			if (input.LA(1)=='A'||input.LA(1)=='a')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(501, 16);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(501, 25);
			if (input.LA(1)=='R'||input.LA(1)=='r')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(501, 34);
			if (input.LA(1)=='A'||input.LA(1)=='a')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(501, 43);
			if (input.LA(1)=='Y'||input.LA(1)=='y')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Array", 67);
			LeaveRule("Array", 67);
			LeaveRule_Array();
		}
	}
	// $ANTLR end "Array"

	partial void EnterRule_RequireOperator();
	partial void LeaveRule_RequireOperator();

	// $ANTLR start "RequireOperator"
	[GrammarRule("RequireOperator")]
	private void mRequireOperator()
	{
		EnterRule_RequireOperator();
		EnterRule("RequireOperator", 68);
		TraceIn("RequireOperator", 68);
		try
		{
			int _type = RequireOperator;
			int _channel = DefaultTokenChannel;
			// Php.g:505:5: ( 'require' | 'require_once' | 'include' | 'include_once' )
			int alt11=4;
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1=='r'))
			{
				int LA11_2 = input.LA(2);

				if ((LA11_2=='e'))
				{
					int LA11_3 = input.LA(3);

					if ((LA11_3=='q'))
					{
						int LA11_4 = input.LA(4);

						if ((LA11_4=='u'))
						{
							int LA11_5 = input.LA(5);

							if ((LA11_5=='i'))
							{
								int LA11_6 = input.LA(6);

								if ((LA11_6=='r'))
								{
									int LA11_7 = input.LA(7);

									if ((LA11_7=='e'))
									{
										int LA11_8 = input.LA(8);

										if ((LA11_8=='_'))
										{
											alt11 = 2;
										}
										else
										{
											alt11 = 1;
										}
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return;}
										NoViableAltException nvae = new NoViableAltException("", 11, 11, input, 7);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else
								{
									if (state.backtracking>0) {state.failed=true; return;}
									NoViableAltException nvae = new NoViableAltException("", 11, 9, input, 6);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return;}
								NoViableAltException nvae = new NoViableAltException("", 11, 7, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 11, 5, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 11, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 11, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA11_1=='i'))
			{
				int LA11_2 = input.LA(2);

				if ((LA11_2=='n'))
				{
					int LA11_3 = input.LA(3);

					if ((LA11_3=='c'))
					{
						int LA11_4 = input.LA(4);

						if ((LA11_4=='l'))
						{
							int LA11_5 = input.LA(5);

							if ((LA11_5=='u'))
							{
								int LA11_6 = input.LA(6);

								if ((LA11_6=='d'))
								{
									int LA11_7 = input.LA(7);

									if ((LA11_7=='e'))
									{
										int LA11_8 = input.LA(8);

										if ((LA11_8=='_'))
										{
											alt11 = 4;
										}
										else
										{
											alt11 = 3;
										}
									}
									else
									{
										if (state.backtracking>0) {state.failed=true; return;}
										NoViableAltException nvae = new NoViableAltException("", 11, 12, input, 7);
										DebugRecognitionException(nvae);
										throw nvae;
									}
								}
								else
								{
									if (state.backtracking>0) {state.failed=true; return;}
									NoViableAltException nvae = new NoViableAltException("", 11, 10, input, 6);
									DebugRecognitionException(nvae);
									throw nvae;
								}
							}
							else
							{
								if (state.backtracking>0) {state.failed=true; return;}
								NoViableAltException nvae = new NoViableAltException("", 11, 8, input, 5);
								DebugRecognitionException(nvae);
								throw nvae;
							}
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return;}
							NoViableAltException nvae = new NoViableAltException("", 11, 6, input, 4);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 11, 4, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 11, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 11, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:505:7: 'require'
				{
				DebugLocation(505, 7);
				Match("require"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:505:19: 'require_once'
				{
				DebugLocation(505, 19);
				Match("require_once"); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:505:36: 'include'
				{
				DebugLocation(505, 36);
				Match("include"); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Php.g:505:48: 'include_once'
				{
				DebugLocation(505, 48);
				Match("include_once"); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RequireOperator", 68);
			LeaveRule("RequireOperator", 68);
			LeaveRule_RequireOperator();
		}
	}
	// $ANTLR end "RequireOperator"

	partial void EnterRule_PrimitiveType();
	partial void LeaveRule_PrimitiveType();

	// $ANTLR start "PrimitiveType"
	[GrammarRule("PrimitiveType")]
	private void mPrimitiveType()
	{
		EnterRule_PrimitiveType();
		EnterRule("PrimitiveType", 69);
		TraceIn("PrimitiveType", 69);
		try
		{
			int _type = PrimitiveType;
			int _channel = DefaultTokenChannel;
			// Php.g:509:5: ( 'int' | 'float' | 'string' | 'array' | 'object' | 'bool' )
			int alt12=6;
			try { DebugEnterDecision(12, false);
			switch (input.LA(1))
			{
			case 'i':
				{
				alt12 = 1;
				}
				break;
			case 'f':
				{
				alt12 = 2;
				}
				break;
			case 's':
				{
				alt12 = 3;
				}
				break;
			case 'a':
				{
				alt12 = 4;
				}
				break;
			case 'o':
				{
				alt12 = 5;
				}
				break;
			case 'b':
				{
				alt12 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 12, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:509:7: 'int'
				{
				DebugLocation(509, 7);
				Match("int"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:509:13: 'float'
				{
				DebugLocation(509, 13);
				Match("float"); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:509:21: 'string'
				{
				DebugLocation(509, 21);
				Match("string"); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Php.g:509:30: 'array'
				{
				DebugLocation(509, 30);
				Match("array"); if (state.failed) return;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Php.g:509:38: 'object'
				{
				DebugLocation(509, 38);
				Match("object"); if (state.failed) return;


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Php.g:509:47: 'bool'
				{
				DebugLocation(509, 47);
				Match("bool"); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PrimitiveType", 69);
			LeaveRule("PrimitiveType", 69);
			LeaveRule_PrimitiveType();
		}
	}
	// $ANTLR end "PrimitiveType"

	partial void EnterRule_AccessModifier();
	partial void LeaveRule_AccessModifier();

	// $ANTLR start "AccessModifier"
	[GrammarRule("AccessModifier")]
	private void mAccessModifier()
	{
		EnterRule_AccessModifier();
		EnterRule("AccessModifier", 70);
		TraceIn("AccessModifier", 70);
		try
		{
			int _type = AccessModifier;
			int _channel = DefaultTokenChannel;
			// Php.g:513:5: ( 'public' | 'private' | 'protected' )
			int alt13=3;
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1=='p'))
			{
				int LA13_2 = input.LA(2);

				if ((LA13_2=='u'))
				{
					alt13 = 1;
				}
				else if ((LA13_2=='r'))
				{
					int LA13_3 = input.LA(3);

					if ((LA13_3=='i'))
					{
						alt13 = 2;
					}
					else if ((LA13_3=='o'))
					{
						alt13 = 3;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 13, 3, input, 3);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 13, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:513:7: 'public'
				{
				DebugLocation(513, 7);
				Match("public"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:513:18: 'private'
				{
				DebugLocation(513, 18);
				Match("private"); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:513:30: 'protected'
				{
				DebugLocation(513, 30);
				Match("protected"); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AccessModifier", 70);
			LeaveRule("AccessModifier", 70);
			LeaveRule_AccessModifier();
		}
	}
	// $ANTLR end "AccessModifier"

	partial void EnterRule_Decimal();
	partial void LeaveRule_Decimal();

	// $ANTLR start "Decimal"
	[GrammarRule("Decimal")]
	private void mDecimal()
	{
		EnterRule_Decimal();
		EnterRule("Decimal", 71);
		TraceIn("Decimal", 71);
		try
		{
			// Php.g:519:2: ( ( '1' .. '9' ( '0' .. '9' )* ) | '0' )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if (((LA15_1>='1' && LA15_1<='9')))
			{
				alt15 = 1;
			}
			else if ((LA15_1=='0'))
			{
				alt15 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:519:3: ( '1' .. '9' ( '0' .. '9' )* )
				{
				DebugLocation(519, 3);
				// Php.g:519:3: ( '1' .. '9' ( '0' .. '9' )* )
				DebugEnterAlt(1);
				// Php.g:519:4: '1' .. '9' ( '0' .. '9' )*
				{
				DebugLocation(519, 7);
				MatchRange('1','9'); if (state.failed) return;
				DebugLocation(519, 13);
				// Php.g:519:13: ( '0' .. '9' )*
				try { DebugEnterSubRule(14);
				while (true)
				{
					int alt14=2;
					try { DebugEnterDecision(14, false);
					int LA14_1 = input.LA(1);

					if (((LA14_1>='0' && LA14_1<='9')))
					{
						alt14 = 1;
					}


					} finally { DebugExitDecision(14); }
					switch ( alt14 )
					{
					case 1:
						DebugEnterAlt(1);
						// Php.g:
						{
						DebugLocation(519, 13);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop14;
					}
				}

				loop14:
					;

				} finally { DebugExitSubRule(14); }


				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:519:26: '0'
				{
				DebugLocation(519, 26);
				Match('0'); if (state.failed) return;

				}
				break;

			}
		}
		finally
		{
			TraceOut("Decimal", 71);
			LeaveRule("Decimal", 71);
			LeaveRule_Decimal();
		}
	}
	// $ANTLR end "Decimal"

	partial void EnterRule_Hexadecimal();
	partial void LeaveRule_Hexadecimal();

	// $ANTLR start "Hexadecimal"
	[GrammarRule("Hexadecimal")]
	private void mHexadecimal()
	{
		EnterRule_Hexadecimal();
		EnterRule("Hexadecimal", 72);
		TraceIn("Hexadecimal", 72);
		try
		{
			// Php.g:523:2: ( '0' ( 'x' | 'X' ) ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ )
			DebugEnterAlt(1);
			// Php.g:523:4: '0' ( 'x' | 'X' ) ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
			{
			DebugLocation(523, 4);
			Match('0'); if (state.failed) return;
			DebugLocation(523, 7);
			if (input.LA(1)=='X'||input.LA(1)=='x')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(523, 16);
			// Php.g:523:16: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
			int cnt16=0;
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if (((LA16_1>='0' && LA16_1<='9')||(LA16_1>='A' && LA16_1<='F')||(LA16_1>='a' && LA16_1<='f')))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:
					{
					DebugLocation(523, 16);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt16 >= 1)
						goto loop16;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee16 = new EarlyExitException( 16, input );
					DebugRecognitionException(eee16);
					throw eee16;
				}
				cnt16++;
			}
			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

		}
		finally
		{
			TraceOut("Hexadecimal", 72);
			LeaveRule("Hexadecimal", 72);
			LeaveRule_Hexadecimal();
		}
	}
	// $ANTLR end "Hexadecimal"

	partial void EnterRule_Octal();
	partial void LeaveRule_Octal();

	// $ANTLR start "Octal"
	[GrammarRule("Octal")]
	private void mOctal()
	{
		EnterRule_Octal();
		EnterRule("Octal", 73);
		TraceIn("Octal", 73);
		try
		{
			// Php.g:528:2: ( '0' ( '0' .. '7' )+ )
			DebugEnterAlt(1);
			// Php.g:528:4: '0' ( '0' .. '7' )+
			{
			DebugLocation(528, 4);
			Match('0'); if (state.failed) return;
			DebugLocation(528, 7);
			// Php.g:528:7: ( '0' .. '7' )+
			int cnt17=0;
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=2;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if (((LA17_1>='0' && LA17_1<='7')))
				{
					alt17 = 1;
				}


				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:
					{
					DebugLocation(528, 7);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt17 >= 1)
						goto loop17;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee17 = new EarlyExitException( 17, input );
					DebugRecognitionException(eee17);
					throw eee17;
				}
				cnt17++;
			}
			loop17:
				;

			} finally { DebugExitSubRule(17); }


			}

		}
		finally
		{
			TraceOut("Octal", 73);
			LeaveRule("Octal", 73);
			LeaveRule_Octal();
		}
	}
	// $ANTLR end "Octal"

	partial void EnterRule_Integer();
	partial void LeaveRule_Integer();

	// $ANTLR start "Integer"
	[GrammarRule("Integer")]
	private void mInteger()
	{
		EnterRule_Integer();
		EnterRule("Integer", 74);
		TraceIn("Integer", 74);
		try
		{
			int _type = Integer;
			int _channel = DefaultTokenChannel;
			// Php.g:530:2: ( Octal | Decimal | Hexadecimal )
			int alt18=3;
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1=='0'))
			{
				switch (input.LA(2))
				{
				case 'X':
				case 'x':
					{
					alt18 = 3;
					}
					break;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
					{
					alt18 = 1;
					}
					break;
				default:
					alt18=2;
					break;

				}

			}
			else if (((LA18_1>='1' && LA18_1<='9')))
			{
				alt18 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 18, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:530:3: Octal
				{
				DebugLocation(530, 3);
				mOctal(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:530:9: Decimal
				{
				DebugLocation(530, 9);
				mDecimal(); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:530:17: Hexadecimal
				{
				DebugLocation(530, 17);
				mHexadecimal(); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Integer", 74);
			LeaveRule("Integer", 74);
			LeaveRule_Integer();
		}
	}
	// $ANTLR end "Integer"

	partial void EnterRule_Digits();
	partial void LeaveRule_Digits();

	// $ANTLR start "Digits"
	[GrammarRule("Digits")]
	private void mDigits()
	{
		EnterRule_Digits();
		EnterRule("Digits", 75);
		TraceIn("Digits", 75);
		try
		{
			// Php.g:536:2: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// Php.g:536:4: ( '0' .. '9' )+
			{
			DebugLocation(536, 7);
			// Php.g:536:7: ( '0' .. '9' )+
			int cnt19=0;
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if (((LA19_1>='0' && LA19_1<='9')))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch (alt19)
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:
					{
					DebugLocation(536, 7);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt19 >= 1)
						goto loop19;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee19 = new EarlyExitException( 19, input );
					DebugRecognitionException(eee19);
					throw eee19;
				}
				cnt19++;
			}
			loop19:
				;

			} finally { DebugExitSubRule(19); }


			}

		}
		finally
		{
			TraceOut("Digits", 75);
			LeaveRule("Digits", 75);
			LeaveRule_Digits();
		}
	}
	// $ANTLR end "Digits"

	partial void EnterRule_DNum();
	partial void LeaveRule_DNum();

	// $ANTLR start "DNum"
	[GrammarRule("DNum")]
	private void mDNum()
	{
		EnterRule_DNum();
		EnterRule("DNum", 76);
		TraceIn("DNum", 76);
		try
		{
			// Php.g:541:2: ( ( ( '.' Digits )=> ( '.' Digits ) | ( Digits '.' ( Digits )? ) ) )
			DebugEnterAlt(1);
			// Php.g:541:3: ( ( '.' Digits )=> ( '.' Digits ) | ( Digits '.' ( Digits )? ) )
			{
			DebugLocation(541, 3);
			// Php.g:541:3: ( ( '.' Digits )=> ( '.' Digits ) | ( Digits '.' ( Digits )? ) )
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_1 = input.LA(1);

			if ((LA21_1=='.') && (EvaluatePredicate(synpred6_Php_fragment)))
			{
				alt21 = 1;
			}
			else if (((LA21_1>='0' && LA21_1<='9')))
			{
				alt21 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:541:4: ( '.' Digits )=> ( '.' Digits )
				{
				DebugLocation(541, 18);
				// Php.g:541:18: ( '.' Digits )
				DebugEnterAlt(1);
				// Php.g:541:19: '.' Digits
				{
				DebugLocation(541, 19);
				Match('.'); if (state.failed) return;
				DebugLocation(541, 23);
				mDigits(); if (state.failed) return;

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:541:31: ( Digits '.' ( Digits )? )
				{
				DebugLocation(541, 31);
				// Php.g:541:31: ( Digits '.' ( Digits )? )
				DebugEnterAlt(1);
				// Php.g:541:32: Digits '.' ( Digits )?
				{
				DebugLocation(541, 32);
				mDigits(); if (state.failed) return;
				DebugLocation(541, 39);
				Match('.'); if (state.failed) return;
				DebugLocation(541, 43);
				// Php.g:541:43: ( Digits )?
				int alt20=2;
				try { DebugEnterSubRule(20);
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if (((LA20_1>='0' && LA20_1<='9')))
				{
					alt20 = 1;
				}
				} finally { DebugExitDecision(20); }
				switch (alt20)
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:541:43: Digits
					{
					DebugLocation(541, 43);
					mDigits(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(20); }


				}


				}
				break;

			}
			} finally { DebugExitSubRule(21); }


			}

		}
		finally
		{
			TraceOut("DNum", 76);
			LeaveRule("DNum", 76);
			LeaveRule_DNum();
		}
	}
	// $ANTLR end "DNum"

	partial void EnterRule_Exponent_DNum();
	partial void LeaveRule_Exponent_DNum();

	// $ANTLR start "Exponent_DNum"
	[GrammarRule("Exponent_DNum")]
	private void mExponent_DNum()
	{
		EnterRule_Exponent_DNum();
		EnterRule("Exponent_DNum", 77);
		TraceIn("Exponent_DNum", 77);
		try
		{
			// Php.g:546:2: ( ( ( Digits | DNum ) ( 'e' | 'E' ) ( '+' '-' )? Digits ) )
			DebugEnterAlt(1);
			// Php.g:546:3: ( ( Digits | DNum ) ( 'e' | 'E' ) ( '+' '-' )? Digits )
			{
			DebugLocation(546, 3);
			// Php.g:546:3: ( ( Digits | DNum ) ( 'e' | 'E' ) ( '+' '-' )? Digits )
			DebugEnterAlt(1);
			// Php.g:546:4: ( Digits | DNum ) ( 'e' | 'E' ) ( '+' '-' )? Digits
			{
			DebugLocation(546, 4);
			// Php.g:546:4: ( Digits | DNum )
			int alt22=2;
			try { DebugEnterSubRule(22);
			try { DebugEnterDecision(22, false);
			try
			{
				alt22 = dfa22.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:546:5: Digits
				{
				DebugLocation(546, 5);
				mDigits(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:546:12: DNum
				{
				DebugLocation(546, 12);
				mDNum(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(22); }

			DebugLocation(546, 17);
			input.Consume();
			state.failed=false;
			DebugLocation(546, 26);
			// Php.g:546:26: ( '+' '-' )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1=='+'))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:546:27: '+' '-'
				{
				DebugLocation(546, 27);
				Match('+'); if (state.failed) return;
				DebugLocation(546, 30);
				Match('-'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(546, 35);
			mDigits(); if (state.failed) return;

			}


			}

		}
		finally
		{
			TraceOut("Exponent_DNum", 77);
			LeaveRule("Exponent_DNum", 77);
			LeaveRule_Exponent_DNum();
		}
	}
	// $ANTLR end "Exponent_DNum"

	partial void EnterRule_Real();
	partial void LeaveRule_Real();

	// $ANTLR start "Real"
	[GrammarRule("Real")]
	private void mReal()
	{
		EnterRule_Real();
		EnterRule("Real", 78);
		TraceIn("Real", 78);
		try
		{
			int _type = Real;
			int _channel = DefaultTokenChannel;
			// Php.g:549:5: ( DNum | Exponent_DNum )
			int alt24=2;
			try { DebugEnterDecision(24, false);
			try
			{
				alt24 = dfa24.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:549:7: DNum
				{
				DebugLocation(549, 7);
				mDNum(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:549:12: Exponent_DNum
				{
				DebugLocation(549, 12);
				mExponent_DNum(); if (state.failed) return;

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Real", 78);
			LeaveRule("Real", 78);
			LeaveRule_Real();
		}
	}
	// $ANTLR end "Real"

	partial void EnterRule_Boolean();
	partial void LeaveRule_Boolean();

	// $ANTLR start "Boolean"
	[GrammarRule("Boolean")]
	private void mBoolean()
	{
		EnterRule_Boolean();
		EnterRule("Boolean", 79);
		TraceIn("Boolean", 79);
		try
		{
			int _type = Boolean;
			int _channel = DefaultTokenChannel;
			// Php.g:553:5: ( 'true' | 'false' )
			int alt25=2;
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1=='t'))
			{
				alt25 = 1;
			}
			else if ((LA25_1=='f'))
			{
				alt25 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:553:7: 'true'
				{
				DebugLocation(553, 7);
				Match("true"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:553:16: 'false'
				{
				DebugLocation(553, 16);
				Match("false"); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("Boolean", 79);
			LeaveRule("Boolean", 79);
			LeaveRule_Boolean();
		}
	}
	// $ANTLR end "Boolean"

	partial void EnterRule_SingleQuotedString();
	partial void LeaveRule_SingleQuotedString();

	// $ANTLR start "SingleQuotedString"
	[GrammarRule("SingleQuotedString")]
	private void mSingleQuotedString()
	{
		EnterRule_SingleQuotedString();
		EnterRule("SingleQuotedString", 80);
		TraceIn("SingleQuotedString", 80);
		try
		{
			int _type = SingleQuotedString;
			int _channel = DefaultTokenChannel;
			// Php.g:557:5: ( '\\'' ( ( '\\\\' '\\'' )=> '\\\\' '\\'' | ( '\\\\' '\\\\' )=> '\\\\' '\\\\' | '\\\\' |~ ( '\\'' | '\\\\' ) )* '\\'' )
			DebugEnterAlt(1);
			// Php.g:557:7: '\\'' ( ( '\\\\' '\\'' )=> '\\\\' '\\'' | ( '\\\\' '\\\\' )=> '\\\\' '\\\\' | '\\\\' |~ ( '\\'' | '\\\\' ) )* '\\''
			{
			DebugLocation(557, 7);
			Match('\''); if (state.failed) return;
			DebugLocation(557, 12);
			// Php.g:557:12: ( ( '\\\\' '\\'' )=> '\\\\' '\\'' | ( '\\\\' '\\\\' )=> '\\\\' '\\\\' | '\\\\' |~ ( '\\'' | '\\\\' ) )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=5;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1=='\\'))
				{
					int LA26_2 = input.LA(2);

					if ((LA26_2=='\''))
					{
						int LA26_3 = input.LA(3);

						if ((LA26_3=='\'') && (EvaluatePredicate(synpred7_Php_fragment)))
						{
							alt26 = 1;
						}
						else if ((LA26_3=='\\') && (EvaluatePredicate(synpred7_Php_fragment)))
						{
							alt26 = 1;
						}
						else if (((LA26_3>='\u0000' && LA26_3<='&')||(LA26_3>='(' && LA26_3<='[')||(LA26_3>=']' && LA26_3<='\uFFFF')) && (EvaluatePredicate(synpred7_Php_fragment)))
						{
							alt26 = 1;
						}

						else
						{
							alt26 = 3;
						}


					}
					else if ((LA26_2=='\\'))
					{
						int LA26_3 = input.LA(3);

						if ((EvaluatePredicate(synpred8_Php_fragment)))
						{
							alt26 = 2;
						}
						else if ((true))
						{
							alt26 = 3;
						}


					}
					else if (((LA26_2>='\u0000' && LA26_2<='&')||(LA26_2>='(' && LA26_2<='[')||(LA26_2>=']' && LA26_2<='\uFFFF')))
					{
						alt26 = 3;
					}


				}
				else if (((LA26_1>='\u0000' && LA26_1<='&')||(LA26_1>='(' && LA26_1<='[')||(LA26_1>=']' && LA26_1<='\uFFFF')))
				{
					alt26 = 4;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:557:13: ( '\\\\' '\\'' )=> '\\\\' '\\''
					{
					DebugLocation(557, 26);
					Match('\\'); if (state.failed) return;
					DebugLocation(557, 31);
					Match('\''); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Php.g:558:15: ( '\\\\' '\\\\' )=> '\\\\' '\\\\'
					{
					DebugLocation(558, 28);
					Match('\\'); if (state.failed) return;
					DebugLocation(558, 33);
					Match('\\'); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Php.g:559:15: '\\\\'
					{
					DebugLocation(559, 15);
					Match('\\'); if (state.failed) return;

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// Php.g:559:22: ~ ( '\\'' | '\\\\' )
					{
					DebugLocation(559, 22);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }

			DebugLocation(560, 7);
			Match('\''); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SingleQuotedString", 80);
			LeaveRule("SingleQuotedString", 80);
			LeaveRule_SingleQuotedString();
		}
	}
	// $ANTLR end "SingleQuotedString"

	partial void EnterRule_EscapeCharector();
	partial void LeaveRule_EscapeCharector();

	// $ANTLR start "EscapeCharector"
	[GrammarRule("EscapeCharector")]
	private void mEscapeCharector()
	{
		EnterRule_EscapeCharector();
		EnterRule("EscapeCharector", 81);
		TraceIn("EscapeCharector", 81);
		try
		{
			// Php.g:566:5: ( 'n' | 'r' | 't' | '\\\\' | '$' | '\"' | Digits | 'x' )
			int alt27=8;
			try { DebugEnterDecision(27, false);
			switch (input.LA(1))
			{
			case 'n':
				{
				alt27 = 1;
				}
				break;
			case 'r':
				{
				alt27 = 2;
				}
				break;
			case 't':
				{
				alt27 = 3;
				}
				break;
			case '\\':
				{
				alt27 = 4;
				}
				break;
			case '$':
				{
				alt27 = 5;
				}
				break;
			case '\"':
				{
				alt27 = 6;
				}
				break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				{
				alt27 = 7;
				}
				break;
			case 'x':
				{
				alt27 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:566:7: 'n'
				{
				DebugLocation(566, 7);
				Match('n'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:566:13: 'r'
				{
				DebugLocation(566, 13);
				Match('r'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:566:19: 't'
				{
				DebugLocation(566, 19);
				Match('t'); if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Php.g:566:25: '\\\\'
				{
				DebugLocation(566, 25);
				Match('\\'); if (state.failed) return;

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Php.g:566:32: '$'
				{
				DebugLocation(566, 32);
				Match('$'); if (state.failed) return;

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Php.g:566:38: '\"'
				{
				DebugLocation(566, 38);
				Match('\"'); if (state.failed) return;

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Php.g:566:44: Digits
				{
				DebugLocation(566, 44);
				mDigits(); if (state.failed) return;

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Php.g:566:53: 'x'
				{
				DebugLocation(566, 53);
				Match('x'); if (state.failed) return;

				}
				break;

			}
		}
		finally
		{
			TraceOut("EscapeCharector", 81);
			LeaveRule("EscapeCharector", 81);
			LeaveRule_EscapeCharector();
		}
	}
	// $ANTLR end "EscapeCharector"

	partial void EnterRule_DoubleQuotedString();
	partial void LeaveRule_DoubleQuotedString();

	// $ANTLR start "DoubleQuotedString"
	[GrammarRule("DoubleQuotedString")]
	private void mDoubleQuotedString()
	{
		EnterRule_DoubleQuotedString();
		EnterRule("DoubleQuotedString", 82);
		TraceIn("DoubleQuotedString", 82);
		try
		{
			int _type = DoubleQuotedString;
			int _channel = DefaultTokenChannel;
			// Php.g:569:5: ( '\"' ( ( '\\\\' EscapeCharector )=> '\\\\' EscapeCharector | '\\\\' |~ ( '\\\\' | '\"' ) )* '\"' )
			DebugEnterAlt(1);
			// Php.g:569:7: '\"' ( ( '\\\\' EscapeCharector )=> '\\\\' EscapeCharector | '\\\\' |~ ( '\\\\' | '\"' ) )* '\"'
			{
			DebugLocation(569, 7);
			Match('\"'); if (state.failed) return;
			DebugLocation(569, 12);
			// Php.g:569:12: ( ( '\\\\' EscapeCharector )=> '\\\\' EscapeCharector | '\\\\' |~ ( '\\\\' | '\"' ) )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=4;
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1=='\\'))
				{
					int LA28_2 = input.LA(2);

					if ((LA28_2=='n'))
					{
						int LA28_3 = input.LA(3);

						if ((EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}


					}
					else if ((LA28_2=='r'))
					{
						int LA28_3 = input.LA(3);

						if ((EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}


					}
					else if ((LA28_2=='t'))
					{
						int LA28_3 = input.LA(3);

						if ((EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}


					}
					else if ((LA28_2=='\\'))
					{
						int LA28_3 = input.LA(3);

						if ((EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}


					}
					else if ((LA28_2=='$'))
					{
						int LA28_3 = input.LA(3);

						if ((EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}


					}
					else if ((LA28_2=='\"'))
					{
						int LA28_3 = input.LA(3);

						if ((LA28_3=='\"') && (EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((LA28_3=='\\') && (EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if (((LA28_3>='\u0000' && LA28_3<='!')||(LA28_3>='#' && LA28_3<='[')||(LA28_3>=']' && LA28_3<='\uFFFF')) && (EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}

						else
						{
							alt28 = 2;
						}


					}
					else if (((LA28_2>='0' && LA28_2<='9')))
					{
						int LA28_3 = input.LA(3);

						if ((EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}


					}
					else if ((LA28_2=='x'))
					{
						int LA28_3 = input.LA(3);

						if ((EvaluatePredicate(synpred9_Php_fragment)))
						{
							alt28 = 1;
						}
						else if ((true))
						{
							alt28 = 2;
						}


					}
					else if (((LA28_2>='\u0000' && LA28_2<='!')||LA28_2=='#'||(LA28_2>='%' && LA28_2<='/')||(LA28_2>=':' && LA28_2<='[')||(LA28_2>=']' && LA28_2<='m')||(LA28_2>='o' && LA28_2<='q')||LA28_2=='s'||(LA28_2>='u' && LA28_2<='w')||(LA28_2>='y' && LA28_2<='\uFFFF')))
					{
						alt28 = 2;
					}


				}
				else if (((LA28_1>='\u0000' && LA28_1<='!')||(LA28_1>='#' && LA28_1<='[')||(LA28_1>=']' && LA28_1<='\uFFFF')))
				{
					alt28 = 3;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:569:14: ( '\\\\' EscapeCharector )=> '\\\\' EscapeCharector
					{
					DebugLocation(569, 39);
					Match('\\'); if (state.failed) return;
					DebugLocation(569, 44);
					mEscapeCharector(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// Php.g:570:7: '\\\\'
					{
					DebugLocation(570, 7);
					Match('\\'); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// Php.g:571:7: ~ ( '\\\\' | '\"' )
					{
					DebugLocation(571, 7);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }

			DebugLocation(572, 7);
			Match('\"'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DoubleQuotedString", 82);
			LeaveRule("DoubleQuotedString", 82);
			LeaveRule_DoubleQuotedString();
		}
	}
	// $ANTLR end "DoubleQuotedString"

	partial void EnterRule_HereDoc();
	partial void LeaveRule_HereDoc();

	// $ANTLR start "HereDoc"
	[GrammarRule("HereDoc")]
	private void mHereDoc()
	{
		EnterRule_HereDoc();
		EnterRule("HereDoc", 83);
		TraceIn("HereDoc", 83);
		try
		{
			int _type = HereDoc;
			int _channel = DefaultTokenChannel;
			// Php.g:576:5: ( '<<<' HereDocContents )
			DebugEnterAlt(1);
			// Php.g:576:7: '<<<' HereDocContents
			{
			DebugLocation(576, 7);
			Match("<<<"); if (state.failed) return;

			DebugLocation(576, 13);
			mHereDocContents(); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HereDoc", 83);
			LeaveRule("HereDoc", 83);
			LeaveRule_HereDoc();
		}
	}
	// $ANTLR end "HereDoc"

	partial void EnterRule_UnquotedString();
	partial void LeaveRule_UnquotedString();

	// $ANTLR start "UnquotedString"
	[GrammarRule("UnquotedString")]
	private void mUnquotedString()
	{
		EnterRule_UnquotedString();
		EnterRule("UnquotedString", 84);
		TraceIn("UnquotedString", 84);
		try
		{
			int _type = UnquotedString;
			int _channel = DefaultTokenChannel;
			// Php.g:581:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
			DebugEnterAlt(1);
			// Php.g:581:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
			{
			DebugLocation(581, 6);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(581, 35);
			// Php.g:581:35: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if (((LA29_1>='0' && LA29_1<='9')||(LA29_1>='A' && LA29_1<='Z')||LA29_1=='_'||(LA29_1>='a' && LA29_1<='z')))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch ( alt29 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:
					{
					DebugLocation(581, 35);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop29;
				}
			}

			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UnquotedString", 84);
			LeaveRule("UnquotedString", 84);
			LeaveRule_UnquotedString();
		}
	}
	// $ANTLR end "UnquotedString"

	partial void EnterRule_HereDocContents();
	partial void LeaveRule_HereDocContents();

	// $ANTLR start "HereDocContents"
	[GrammarRule("HereDocContents")]
	private void mHereDocContents()
	{
		EnterRule_HereDocContents();
		EnterRule("HereDocContents", 85);
		TraceIn("HereDocContents", 85);
		try
		{
			// Php.g:588:5: ()
			DebugEnterAlt(1);
			// Php.g:588:7: 
			{
			DebugLocation(588, 7);
			if (state.backtracking == 0)
			{

				        StringBuilder sb = new StringBuilder();
				        while(input.LA(1)!='\n'){
				            sb.append((char)input.LA(1));
				            input.consume();
				        }
				        input.consume();
				        String hereDocName = sb.toString();
				        int hdnl = hereDocName.length();
				        while(true){
				            boolean matchEnd = true;
				            for(int i = 0; i<hdnl; i++){
				                if(input.LA(1)!=hereDocName.charAt(i)){
				                    matchEnd=false;
				                    break;
				                }
				                input.consume();
				            }
				            if(matchEnd==false){
				                while(input.LA(1)!='\n'){
				                    input.consume();
				                }
				                input.consume();
				            }else{
				                break;
				            }
				        }
				    
			}

			}

		}
		finally
		{
			TraceOut("HereDocContents", 85);
			LeaveRule("HereDocContents", 85);
			LeaveRule_HereDocContents();
		}
	}
	// $ANTLR end "HereDocContents"

	partial void EnterRule_AsignmentOperator();
	partial void LeaveRule_AsignmentOperator();

	// $ANTLR start "AsignmentOperator"
	[GrammarRule("AsignmentOperator")]
	private void mAsignmentOperator()
	{
		EnterRule_AsignmentOperator();
		EnterRule("AsignmentOperator", 86);
		TraceIn("AsignmentOperator", 86);
		try
		{
			int _type = AsignmentOperator;
			int _channel = DefaultTokenChannel;
			// Php.g:618:5: ( '+=' | '-=' | '*=' | '/=' | '.=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' )
			int alt30=11;
			try { DebugEnterDecision(30, false);
			switch (input.LA(1))
			{
			case '+':
				{
				alt30 = 1;
				}
				break;
			case '-':
				{
				alt30 = 2;
				}
				break;
			case '*':
				{
				alt30 = 3;
				}
				break;
			case '/':
				{
				alt30 = 4;
				}
				break;
			case '.':
				{
				alt30 = 5;
				}
				break;
			case '%':
				{
				alt30 = 6;
				}
				break;
			case '&':
				{
				alt30 = 7;
				}
				break;
			case '|':
				{
				alt30 = 8;
				}
				break;
			case '^':
				{
				alt30 = 9;
				}
				break;
			case '<':
				{
				alt30 = 10;
				}
				break;
			case '>':
				{
				alt30 = 11;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 30, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:618:7: '+='
				{
				DebugLocation(618, 7);
				Match("+="); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:618:12: '-='
				{
				DebugLocation(618, 12);
				Match("-="); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:618:17: '*='
				{
				DebugLocation(618, 17);
				Match("*="); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Php.g:618:22: '/='
				{
				DebugLocation(618, 22);
				Match("/="); if (state.failed) return;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Php.g:618:27: '.='
				{
				DebugLocation(618, 27);
				Match(".="); if (state.failed) return;


				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Php.g:618:32: '%='
				{
				DebugLocation(618, 32);
				Match("%="); if (state.failed) return;


				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Php.g:618:37: '&='
				{
				DebugLocation(618, 37);
				Match("&="); if (state.failed) return;


				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Php.g:618:42: '|='
				{
				DebugLocation(618, 42);
				Match("|="); if (state.failed) return;


				}
				break;
			case 9:
				DebugEnterAlt(9);
				// Php.g:618:47: '^='
				{
				DebugLocation(618, 47);
				Match("^="); if (state.failed) return;


				}
				break;
			case 10:
				DebugEnterAlt(10);
				// Php.g:618:52: '<<='
				{
				DebugLocation(618, 52);
				Match("<<="); if (state.failed) return;


				}
				break;
			case 11:
				DebugEnterAlt(11);
				// Php.g:618:58: '>>='
				{
				DebugLocation(618, 58);
				Match(">>="); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AsignmentOperator", 86);
			LeaveRule("AsignmentOperator", 86);
			LeaveRule_AsignmentOperator();
		}
	}
	// $ANTLR end "AsignmentOperator"

	partial void EnterRule_EqualityOperator();
	partial void LeaveRule_EqualityOperator();

	// $ANTLR start "EqualityOperator"
	[GrammarRule("EqualityOperator")]
	private void mEqualityOperator()
	{
		EnterRule_EqualityOperator();
		EnterRule("EqualityOperator", 87);
		TraceIn("EqualityOperator", 87);
		try
		{
			int _type = EqualityOperator;
			int _channel = DefaultTokenChannel;
			// Php.g:622:5: ( '==' | '!=' | '===' | '!==' )
			int alt31=4;
			try { DebugEnterDecision(31, false);
			int LA31_1 = input.LA(1);

			if ((LA31_1=='='))
			{
				int LA31_2 = input.LA(2);

				if ((LA31_2=='='))
				{
					int LA31_3 = input.LA(3);

					if ((LA31_3=='='))
					{
						alt31 = 3;
					}
					else
					{
						alt31 = 1;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 31, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA31_1=='!'))
			{
				int LA31_2 = input.LA(2);

				if ((LA31_2=='='))
				{
					int LA31_3 = input.LA(3);

					if ((LA31_3=='='))
					{
						alt31 = 4;
					}
					else
					{
						alt31 = 2;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 31, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 31, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:622:7: '=='
				{
				DebugLocation(622, 7);
				Match("=="); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:622:14: '!='
				{
				DebugLocation(622, 14);
				Match("!="); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:622:21: '==='
				{
				DebugLocation(622, 21);
				Match("==="); if (state.failed) return;


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Php.g:622:29: '!=='
				{
				DebugLocation(622, 29);
				Match("!=="); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EqualityOperator", 87);
			LeaveRule("EqualityOperator", 87);
			LeaveRule_EqualityOperator();
		}
	}
	// $ANTLR end "EqualityOperator"

	partial void EnterRule_ComparisionOperator();
	partial void LeaveRule_ComparisionOperator();

	// $ANTLR start "ComparisionOperator"
	[GrammarRule("ComparisionOperator")]
	private void mComparisionOperator()
	{
		EnterRule_ComparisionOperator();
		EnterRule("ComparisionOperator", 88);
		TraceIn("ComparisionOperator", 88);
		try
		{
			int _type = ComparisionOperator;
			int _channel = DefaultTokenChannel;
			// Php.g:626:5: ( '<' | '<=' | '>' | '>=' | '<>' )
			int alt32=5;
			try { DebugEnterDecision(32, false);
			int LA32_1 = input.LA(1);

			if ((LA32_1=='<'))
			{
				switch (input.LA(2))
				{
				case '=':
					{
					alt32 = 2;
					}
					break;
				case '>':
					{
					alt32 = 5;
					}
					break;
				default:
					alt32=1;
					break;

				}

			}
			else if ((LA32_1=='>'))
			{
				int LA32_2 = input.LA(2);

				if ((LA32_2=='='))
				{
					alt32 = 4;
				}
				else
				{
					alt32 = 3;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:626:7: '<'
				{
				DebugLocation(626, 7);
				Match('<'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:626:13: '<='
				{
				DebugLocation(626, 13);
				Match("<="); if (state.failed) return;


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Php.g:626:20: '>'
				{
				DebugLocation(626, 20);
				Match('>'); if (state.failed) return;

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Php.g:626:26: '>='
				{
				DebugLocation(626, 26);
				Match(">="); if (state.failed) return;


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Php.g:626:33: '<>'
				{
				DebugLocation(626, 33);
				Match("<>"); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ComparisionOperator", 88);
			LeaveRule("ComparisionOperator", 88);
			LeaveRule_ComparisionOperator();
		}
	}
	// $ANTLR end "ComparisionOperator"

	partial void EnterRule_ShiftOperator();
	partial void LeaveRule_ShiftOperator();

	// $ANTLR start "ShiftOperator"
	[GrammarRule("ShiftOperator")]
	private void mShiftOperator()
	{
		EnterRule_ShiftOperator();
		EnterRule("ShiftOperator", 89);
		TraceIn("ShiftOperator", 89);
		try
		{
			int _type = ShiftOperator;
			int _channel = DefaultTokenChannel;
			// Php.g:630:5: ( '<<' | '>>' )
			int alt33=2;
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1=='<'))
			{
				alt33 = 1;
			}
			else if ((LA33_1=='>'))
			{
				alt33 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:630:7: '<<'
				{
				DebugLocation(630, 7);
				Match("<<"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:630:14: '>>'
				{
				DebugLocation(630, 14);
				Match(">>"); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ShiftOperator", 89);
			LeaveRule("ShiftOperator", 89);
			LeaveRule_ShiftOperator();
		}
	}
	// $ANTLR end "ShiftOperator"

	partial void EnterRule_IncrementOperator();
	partial void LeaveRule_IncrementOperator();

	// $ANTLR start "IncrementOperator"
	[GrammarRule("IncrementOperator")]
	private void mIncrementOperator()
	{
		EnterRule_IncrementOperator();
		EnterRule("IncrementOperator", 90);
		TraceIn("IncrementOperator", 90);
		try
		{
			int _type = IncrementOperator;
			int _channel = DefaultTokenChannel;
			// Php.g:634:5: ( '--' | '++' )
			int alt34=2;
			try { DebugEnterDecision(34, false);
			int LA34_1 = input.LA(1);

			if ((LA34_1=='-'))
			{
				alt34 = 1;
			}
			else if ((LA34_1=='+'))
			{
				alt34 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// Php.g:634:7: '--'
				{
				DebugLocation(634, 7);
				Match("--"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Php.g:634:12: '++'
				{
				DebugLocation(634, 12);
				Match("++"); if (state.failed) return;


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IncrementOperator", 90);
			LeaveRule("IncrementOperator", 90);
			LeaveRule_IncrementOperator();
		}
	}
	// $ANTLR end "IncrementOperator"

	partial void EnterRule_Eol();
	partial void LeaveRule_Eol();

	// $ANTLR start "Eol"
	[GrammarRule("Eol")]
	private void mEol()
	{
		EnterRule_Eol();
		EnterRule("Eol", 91);
		TraceIn("Eol", 91);
		try
		{
			// Php.g:640:5: ( '\\n' )
			DebugEnterAlt(1);
			// Php.g:640:7: '\\n'
			{
			DebugLocation(640, 7);
			Match('\n'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("Eol", 91);
			LeaveRule("Eol", 91);
			LeaveRule_Eol();
		}
	}
	// $ANTLR end "Eol"

	partial void EnterRule_WhiteSpace();
	partial void LeaveRule_WhiteSpace();

	// $ANTLR start "WhiteSpace"
	[GrammarRule("WhiteSpace")]
	private void mWhiteSpace()
	{
		EnterRule_WhiteSpace();
		EnterRule("WhiteSpace", 92);
		TraceIn("WhiteSpace", 92);
		try
		{
			int _type = WhiteSpace;
			int _channel = DefaultTokenChannel;

			    _channel=HIDDEN;

			// Php.g:646:2: ( ( ' ' | '\\t' | '\\n' | '\\r' )* )
			DebugEnterAlt(1);
			// Php.g:646:4: ( ' ' | '\\t' | '\\n' | '\\r' )*
			{
			DebugLocation(646, 4);
			// Php.g:646:4: ( ' ' | '\\t' | '\\n' | '\\r' )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if (((LA35_1>='\t' && LA35_1<='\n')||LA35_1=='\r'||LA35_1==' '))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// Php.g:
					{
					DebugLocation(646, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WhiteSpace", 92);
			LeaveRule("WhiteSpace", 92);
			LeaveRule_WhiteSpace();
		}
	}
	// $ANTLR end "WhiteSpace"

	public override void mTokens()
	{
		// Php.g:1:8: ( Abstract | Ampersand | And | ArrayAssign | Asterisk | Bang | Break | Case | Class | ClassMember | Clone | CloseCurlyBracket | CloseRoundBracket | CloseSquareBracket | Colon | Comma | Const | Continue | Default | Do | Dollar | Dot | Echo | Else | ElseIf | Equals | Extends | For | Foreach | Forwardslash | Function | Global | If | Implements | InstanceMember | Instanceof | Interface | List | LogicalAnd | LogicalOr | Minus | New | OpenCurlyBracket | OpenRoundBracket | OpenSquareBracket | Or | Percent | Pipe | Plus | QuestionMark | Return | SemiColon | Static | SuppressWarnings | Switch | Tilde | Var | While | Xor | T__113 | BodyString | MultilineComment | SinglelineComment | UnixComment | Array | RequireOperator | PrimitiveType | AccessModifier | Integer | Real | Boolean | SingleQuotedString | DoubleQuotedString | HereDoc | UnquotedString | AsignmentOperator | EqualityOperator | ComparisionOperator | ShiftOperator | IncrementOperator | WhiteSpace )
		int alt36=81;
		try { DebugEnterDecision(36, false);
		try
		{
			alt36 = dfa36.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(36); }
		switch (alt36)
		{
		case 1:
			DebugEnterAlt(1);
			// Php.g:1:10: Abstract
			{
			DebugLocation(1, 10);
			mAbstract(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Php.g:1:19: Ampersand
			{
			DebugLocation(1, 19);
			mAmpersand(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Php.g:1:29: And
			{
			DebugLocation(1, 29);
			mAnd(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Php.g:1:33: ArrayAssign
			{
			DebugLocation(1, 33);
			mArrayAssign(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Php.g:1:45: Asterisk
			{
			DebugLocation(1, 45);
			mAsterisk(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Php.g:1:54: Bang
			{
			DebugLocation(1, 54);
			mBang(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Php.g:1:59: Break
			{
			DebugLocation(1, 59);
			mBreak(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Php.g:1:65: Case
			{
			DebugLocation(1, 65);
			mCase(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Php.g:1:70: Class
			{
			DebugLocation(1, 70);
			mClass(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Php.g:1:76: ClassMember
			{
			DebugLocation(1, 76);
			mClassMember(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Php.g:1:88: Clone
			{
			DebugLocation(1, 88);
			mClone(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Php.g:1:94: CloseCurlyBracket
			{
			DebugLocation(1, 94);
			mCloseCurlyBracket(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Php.g:1:112: CloseRoundBracket
			{
			DebugLocation(1, 112);
			mCloseRoundBracket(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Php.g:1:130: CloseSquareBracket
			{
			DebugLocation(1, 130);
			mCloseSquareBracket(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Php.g:1:149: Colon
			{
			DebugLocation(1, 149);
			mColon(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Php.g:1:155: Comma
			{
			DebugLocation(1, 155);
			mComma(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Php.g:1:161: Const
			{
			DebugLocation(1, 161);
			mConst(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// Php.g:1:167: Continue
			{
			DebugLocation(1, 167);
			mContinue(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// Php.g:1:176: Default
			{
			DebugLocation(1, 176);
			mDefault(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// Php.g:1:184: Do
			{
			DebugLocation(1, 184);
			mDo(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// Php.g:1:187: Dollar
			{
			DebugLocation(1, 187);
			mDollar(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// Php.g:1:194: Dot
			{
			DebugLocation(1, 194);
			mDot(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// Php.g:1:198: Echo
			{
			DebugLocation(1, 198);
			mEcho(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// Php.g:1:203: Else
			{
			DebugLocation(1, 203);
			mElse(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// Php.g:1:208: ElseIf
			{
			DebugLocation(1, 208);
			mElseIf(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// Php.g:1:215: Equals
			{
			DebugLocation(1, 215);
			mEquals(); if (state.failed) return;

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// Php.g:1:222: Extends
			{
			DebugLocation(1, 222);
			mExtends(); if (state.failed) return;

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// Php.g:1:230: For
			{
			DebugLocation(1, 230);
			mFor(); if (state.failed) return;

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// Php.g:1:234: Foreach
			{
			DebugLocation(1, 234);
			mForeach(); if (state.failed) return;

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// Php.g:1:242: Forwardslash
			{
			DebugLocation(1, 242);
			mForwardslash(); if (state.failed) return;

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// Php.g:1:255: Function
			{
			DebugLocation(1, 255);
			mFunction(); if (state.failed) return;

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// Php.g:1:264: Global
			{
			DebugLocation(1, 264);
			mGlobal(); if (state.failed) return;

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// Php.g:1:271: If
			{
			DebugLocation(1, 271);
			mIf(); if (state.failed) return;

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// Php.g:1:274: Implements
			{
			DebugLocation(1, 274);
			mImplements(); if (state.failed) return;

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// Php.g:1:285: InstanceMember
			{
			DebugLocation(1, 285);
			mInstanceMember(); if (state.failed) return;

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// Php.g:1:300: Instanceof
			{
			DebugLocation(1, 300);
			mInstanceof(); if (state.failed) return;

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// Php.g:1:311: Interface
			{
			DebugLocation(1, 311);
			mInterface(); if (state.failed) return;

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// Php.g:1:321: List
			{
			DebugLocation(1, 321);
			mList(); if (state.failed) return;

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// Php.g:1:326: LogicalAnd
			{
			DebugLocation(1, 326);
			mLogicalAnd(); if (state.failed) return;

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// Php.g:1:337: LogicalOr
			{
			DebugLocation(1, 337);
			mLogicalOr(); if (state.failed) return;

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// Php.g:1:347: Minus
			{
			DebugLocation(1, 347);
			mMinus(); if (state.failed) return;

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// Php.g:1:353: New
			{
			DebugLocation(1, 353);
			mNew(); if (state.failed) return;

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// Php.g:1:357: OpenCurlyBracket
			{
			DebugLocation(1, 357);
			mOpenCurlyBracket(); if (state.failed) return;

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// Php.g:1:374: OpenRoundBracket
			{
			DebugLocation(1, 374);
			mOpenRoundBracket(); if (state.failed) return;

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// Php.g:1:391: OpenSquareBracket
			{
			DebugLocation(1, 391);
			mOpenSquareBracket(); if (state.failed) return;

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// Php.g:1:409: Or
			{
			DebugLocation(1, 409);
			mOr(); if (state.failed) return;

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// Php.g:1:412: Percent
			{
			DebugLocation(1, 412);
			mPercent(); if (state.failed) return;

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// Php.g:1:420: Pipe
			{
			DebugLocation(1, 420);
			mPipe(); if (state.failed) return;

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// Php.g:1:425: Plus
			{
			DebugLocation(1, 425);
			mPlus(); if (state.failed) return;

			}
			break;
		case 50:
			DebugEnterAlt(50);
			// Php.g:1:430: QuestionMark
			{
			DebugLocation(1, 430);
			mQuestionMark(); if (state.failed) return;

			}
			break;
		case 51:
			DebugEnterAlt(51);
			// Php.g:1:443: Return
			{
			DebugLocation(1, 443);
			mReturn(); if (state.failed) return;

			}
			break;
		case 52:
			DebugEnterAlt(52);
			// Php.g:1:450: SemiColon
			{
			DebugLocation(1, 450);
			mSemiColon(); if (state.failed) return;

			}
			break;
		case 53:
			DebugEnterAlt(53);
			// Php.g:1:460: Static
			{
			DebugLocation(1, 460);
			mStatic(); if (state.failed) return;

			}
			break;
		case 54:
			DebugEnterAlt(54);
			// Php.g:1:467: SuppressWarnings
			{
			DebugLocation(1, 467);
			mSuppressWarnings(); if (state.failed) return;

			}
			break;
		case 55:
			DebugEnterAlt(55);
			// Php.g:1:484: Switch
			{
			DebugLocation(1, 484);
			mSwitch(); if (state.failed) return;

			}
			break;
		case 56:
			DebugEnterAlt(56);
			// Php.g:1:491: Tilde
			{
			DebugLocation(1, 491);
			mTilde(); if (state.failed) return;

			}
			break;
		case 57:
			DebugEnterAlt(57);
			// Php.g:1:497: Var
			{
			DebugLocation(1, 497);
			mVar(); if (state.failed) return;

			}
			break;
		case 58:
			DebugEnterAlt(58);
			// Php.g:1:501: While
			{
			DebugLocation(1, 501);
			mWhile(); if (state.failed) return;

			}
			break;
		case 59:
			DebugEnterAlt(59);
			// Php.g:1:507: Xor
			{
			DebugLocation(1, 507);
			mXor(); if (state.failed) return;

			}
			break;
		case 60:
			DebugEnterAlt(60);
			// Php.g:1:511: T__113
			{
			DebugLocation(1, 511);
			mT__113(); if (state.failed) return;

			}
			break;
		case 61:
			DebugEnterAlt(61);
			// Php.g:1:518: BodyString
			{
			DebugLocation(1, 518);
			mBodyString(); if (state.failed) return;

			}
			break;
		case 62:
			DebugEnterAlt(62);
			// Php.g:1:529: MultilineComment
			{
			DebugLocation(1, 529);
			mMultilineComment(); if (state.failed) return;

			}
			break;
		case 63:
			DebugEnterAlt(63);
			// Php.g:1:546: SinglelineComment
			{
			DebugLocation(1, 546);
			mSinglelineComment(); if (state.failed) return;

			}
			break;
		case 64:
			DebugEnterAlt(64);
			// Php.g:1:564: UnixComment
			{
			DebugLocation(1, 564);
			mUnixComment(); if (state.failed) return;

			}
			break;
		case 65:
			DebugEnterAlt(65);
			// Php.g:1:576: Array
			{
			DebugLocation(1, 576);
			mArray(); if (state.failed) return;

			}
			break;
		case 66:
			DebugEnterAlt(66);
			// Php.g:1:582: RequireOperator
			{
			DebugLocation(1, 582);
			mRequireOperator(); if (state.failed) return;

			}
			break;
		case 67:
			DebugEnterAlt(67);
			// Php.g:1:598: PrimitiveType
			{
			DebugLocation(1, 598);
			mPrimitiveType(); if (state.failed) return;

			}
			break;
		case 68:
			DebugEnterAlt(68);
			// Php.g:1:612: AccessModifier
			{
			DebugLocation(1, 612);
			mAccessModifier(); if (state.failed) return;

			}
			break;
		case 69:
			DebugEnterAlt(69);
			// Php.g:1:627: Integer
			{
			DebugLocation(1, 627);
			mInteger(); if (state.failed) return;

			}
			break;
		case 70:
			DebugEnterAlt(70);
			// Php.g:1:635: Real
			{
			DebugLocation(1, 635);
			mReal(); if (state.failed) return;

			}
			break;
		case 71:
			DebugEnterAlt(71);
			// Php.g:1:640: Boolean
			{
			DebugLocation(1, 640);
			mBoolean(); if (state.failed) return;

			}
			break;
		case 72:
			DebugEnterAlt(72);
			// Php.g:1:648: SingleQuotedString
			{
			DebugLocation(1, 648);
			mSingleQuotedString(); if (state.failed) return;

			}
			break;
		case 73:
			DebugEnterAlt(73);
			// Php.g:1:667: DoubleQuotedString
			{
			DebugLocation(1, 667);
			mDoubleQuotedString(); if (state.failed) return;

			}
			break;
		case 74:
			DebugEnterAlt(74);
			// Php.g:1:686: HereDoc
			{
			DebugLocation(1, 686);
			mHereDoc(); if (state.failed) return;

			}
			break;
		case 75:
			DebugEnterAlt(75);
			// Php.g:1:694: UnquotedString
			{
			DebugLocation(1, 694);
			mUnquotedString(); if (state.failed) return;

			}
			break;
		case 76:
			DebugEnterAlt(76);
			// Php.g:1:709: AsignmentOperator
			{
			DebugLocation(1, 709);
			mAsignmentOperator(); if (state.failed) return;

			}
			break;
		case 77:
			DebugEnterAlt(77);
			// Php.g:1:727: EqualityOperator
			{
			DebugLocation(1, 727);
			mEqualityOperator(); if (state.failed) return;

			}
			break;
		case 78:
			DebugEnterAlt(78);
			// Php.g:1:744: ComparisionOperator
			{
			DebugLocation(1, 744);
			mComparisionOperator(); if (state.failed) return;

			}
			break;
		case 79:
			DebugEnterAlt(79);
			// Php.g:1:764: ShiftOperator
			{
			DebugLocation(1, 764);
			mShiftOperator(); if (state.failed) return;

			}
			break;
		case 80:
			DebugEnterAlt(80);
			// Php.g:1:778: IncrementOperator
			{
			DebugLocation(1, 778);
			mIncrementOperator(); if (state.failed) return;

			}
			break;
		case 81:
			DebugEnterAlt(81);
			// Php.g:1:796: WhiteSpace
			{
			DebugLocation(1, 796);
			mWhiteSpace(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred1_Php_fragment();
	partial void LeaveRule_synpred1_Php_fragment();

	// $ANTLR start synpred1_Php
	private void synpred1_Php_fragment()
	{
		EnterRule_synpred1_Php_fragment();
		EnterRule("synpred1_Php_fragment", 94);
		TraceIn("synpred1_Php_fragment", 94);
		try
		{
			// Php.g:478:8: ( '<' ~ '?' )
			DebugEnterAlt(1);
			// Php.g:478:9: '<' ~ '?'
			{
			DebugLocation(478, 9);
			Match('<'); if (state.failed) return;
			DebugLocation(478, 13);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='>')||(input.LA(1)>='@' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred1_Php_fragment", 94);
			LeaveRule("synpred1_Php_fragment", 94);
			LeaveRule_synpred1_Php_fragment();
		}
	}
	// $ANTLR end synpred1_Php

	partial void EnterRule_synpred2_Php_fragment();
	partial void LeaveRule_synpred2_Php_fragment();

	// $ANTLR start synpred2_Php
	private void synpred2_Php_fragment()
	{
		EnterRule_synpred2_Php_fragment();
		EnterRule("synpred2_Php_fragment", 95);
		TraceIn("synpred2_Php_fragment", 95);
		try
		{
			// Php.g:483:8: ( '<' ~ '?' )
			DebugEnterAlt(1);
			// Php.g:483:9: '<' ~ '?'
			{
			DebugLocation(483, 9);
			Match('<'); if (state.failed) return;
			DebugLocation(483, 13);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='>')||(input.LA(1)>='@' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred2_Php_fragment", 95);
			LeaveRule("synpred2_Php_fragment", 95);
			LeaveRule_synpred2_Php_fragment();
		}
	}
	// $ANTLR end synpred2_Php

	partial void EnterRule_synpred3_Php_fragment();
	partial void LeaveRule_synpred3_Php_fragment();

	// $ANTLR start synpred3_Php
	private void synpred3_Php_fragment()
	{
		EnterRule_synpred3_Php_fragment();
		EnterRule("synpred3_Php_fragment", 96);
		TraceIn("synpred3_Php_fragment", 96);
		try
		{
			// Php.g:488:13: ( '*' ~ '/' )
			DebugEnterAlt(1);
			// Php.g:488:14: '*' ~ '/'
			{
			DebugLocation(488, 14);
			Match('*'); if (state.failed) return;
			DebugLocation(488, 18);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='.')||(input.LA(1)>='0' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred3_Php_fragment", 96);
			LeaveRule("synpred3_Php_fragment", 96);
			LeaveRule_synpred3_Php_fragment();
		}
	}
	// $ANTLR end synpred3_Php

	partial void EnterRule_synpred4_Php_fragment();
	partial void LeaveRule_synpred4_Php_fragment();

	// $ANTLR start synpred4_Php
	private void synpred4_Php_fragment()
	{
		EnterRule_synpred4_Php_fragment();
		EnterRule("synpred4_Php_fragment", 97);
		TraceIn("synpred4_Php_fragment", 97);
		try
		{
			// Php.g:492:14: ( '?' ~ '>' )
			DebugEnterAlt(1);
			// Php.g:492:15: '?' ~ '>'
			{
			DebugLocation(492, 15);
			Match('?'); if (state.failed) return;
			DebugLocation(492, 19);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred4_Php_fragment", 97);
			LeaveRule("synpred4_Php_fragment", 97);
			LeaveRule_synpred4_Php_fragment();
		}
	}
	// $ANTLR end synpred4_Php

	partial void EnterRule_synpred5_Php_fragment();
	partial void LeaveRule_synpred5_Php_fragment();

	// $ANTLR start synpred5_Php
	private void synpred5_Php_fragment()
	{
		EnterRule_synpred5_Php_fragment();
		EnterRule("synpred5_Php_fragment", 98);
		TraceIn("synpred5_Php_fragment", 98);
		try
		{
			// Php.g:496:12: ( '?' ~ '>' )
			DebugEnterAlt(1);
			// Php.g:496:13: '?' ~ '>'
			{
			DebugLocation(496, 13);
			Match('?'); if (state.failed) return;
			DebugLocation(496, 17);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred5_Php_fragment", 98);
			LeaveRule("synpred5_Php_fragment", 98);
			LeaveRule_synpred5_Php_fragment();
		}
	}
	// $ANTLR end synpred5_Php

	partial void EnterRule_synpred6_Php_fragment();
	partial void LeaveRule_synpred6_Php_fragment();

	// $ANTLR start synpred6_Php
	private void synpred6_Php_fragment()
	{
		EnterRule_synpred6_Php_fragment();
		EnterRule("synpred6_Php_fragment", 99);
		TraceIn("synpred6_Php_fragment", 99);
		try
		{
			// Php.g:541:4: ( '.' Digits )
			DebugEnterAlt(1);
			// Php.g:541:5: '.' Digits
			{
			DebugLocation(541, 5);
			Match('.'); if (state.failed) return;
			DebugLocation(541, 9);
			mDigits(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_Php_fragment", 99);
			LeaveRule("synpred6_Php_fragment", 99);
			LeaveRule_synpred6_Php_fragment();
		}
	}
	// $ANTLR end synpred6_Php

	partial void EnterRule_synpred7_Php_fragment();
	partial void LeaveRule_synpred7_Php_fragment();

	// $ANTLR start synpred7_Php
	private void synpred7_Php_fragment()
	{
		EnterRule_synpred7_Php_fragment();
		EnterRule("synpred7_Php_fragment", 100);
		TraceIn("synpred7_Php_fragment", 100);
		try
		{
			// Php.g:557:13: ( '\\\\' '\\'' )
			DebugEnterAlt(1);
			// Php.g:557:14: '\\\\' '\\''
			{
			DebugLocation(557, 14);
			Match('\\'); if (state.failed) return;
			DebugLocation(557, 19);
			Match('\''); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_Php_fragment", 100);
			LeaveRule("synpred7_Php_fragment", 100);
			LeaveRule_synpred7_Php_fragment();
		}
	}
	// $ANTLR end synpred7_Php

	partial void EnterRule_synpred8_Php_fragment();
	partial void LeaveRule_synpred8_Php_fragment();

	// $ANTLR start synpred8_Php
	private void synpred8_Php_fragment()
	{
		EnterRule_synpred8_Php_fragment();
		EnterRule("synpred8_Php_fragment", 101);
		TraceIn("synpred8_Php_fragment", 101);
		try
		{
			// Php.g:558:15: ( '\\\\' '\\\\' )
			DebugEnterAlt(1);
			// Php.g:558:16: '\\\\' '\\\\'
			{
			DebugLocation(558, 16);
			Match('\\'); if (state.failed) return;
			DebugLocation(558, 21);
			Match('\\'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred8_Php_fragment", 101);
			LeaveRule("synpred8_Php_fragment", 101);
			LeaveRule_synpred8_Php_fragment();
		}
	}
	// $ANTLR end synpred8_Php

	partial void EnterRule_synpred9_Php_fragment();
	partial void LeaveRule_synpred9_Php_fragment();

	// $ANTLR start synpred9_Php
	private void synpred9_Php_fragment()
	{
		EnterRule_synpred9_Php_fragment();
		EnterRule("synpred9_Php_fragment", 102);
		TraceIn("synpred9_Php_fragment", 102);
		try
		{
			// Php.g:569:14: ( '\\\\' EscapeCharector )
			DebugEnterAlt(1);
			// Php.g:569:15: '\\\\' EscapeCharector
			{
			DebugLocation(569, 15);
			Match('\\'); if (state.failed) return;
			DebugLocation(569, 20);
			mEscapeCharector(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_Php_fragment", 102);
			LeaveRule("synpred9_Php_fragment", 102);
			LeaveRule_synpred9_Php_fragment();
		}
	}
	// $ANTLR end synpred9_Php

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA22 dfa22;
	DFA24 dfa24;
	DFA36 dfa36;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa22 = new DFA22(this);
		dfa24 = new DFA24(this);
		dfa36 = new DFA36(this);
	}

	private class DFA22 : DFA
	{
		private const string DFA22_eotS =
			"\x4\xFFFF";
		private const string DFA22_eofS =
			"\x4\xFFFF";
		private const string DFA22_minS =
			"\x2\x2E\x2\xFFFF";
		private const string DFA22_maxS =
			"\x1\x39\x1\x65\x2\xFFFF";
		private const string DFA22_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA22_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA22_transitionS =
			{
				"\x1\x2\x1\xFFFF\xA\x1",
				"\x1\x2\x1\xFFFF\xA\x1\xB\xFFFF\x1\x3\x1F\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA22_eot = DFA.UnpackEncodedString(DFA22_eotS);
		private static readonly short[] DFA22_eof = DFA.UnpackEncodedString(DFA22_eofS);
		private static readonly char[] DFA22_min = DFA.UnpackEncodedStringToUnsignedChars(DFA22_minS);
		private static readonly char[] DFA22_max = DFA.UnpackEncodedStringToUnsignedChars(DFA22_maxS);
		private static readonly short[] DFA22_accept = DFA.UnpackEncodedString(DFA22_acceptS);
		private static readonly short[] DFA22_special = DFA.UnpackEncodedString(DFA22_specialS);
		private static readonly short[][] DFA22_transition;

		static DFA22()
		{
			int numStates = DFA22_transitionS.Length;
			DFA22_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA22_transition[i] = DFA.UnpackEncodedString(DFA22_transitionS[i]);
			}
		}

		public DFA22( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 22;
			this.eot = DFA22_eot;
			this.eof = DFA22_eof;
			this.min = DFA22_min;
			this.max = DFA22_max;
			this.accept = DFA22_accept;
			this.special = DFA22_special;
			this.transition = DFA22_transition;
		}

		public override string Description { get { return "546:4: ( Digits | DNum )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA24 : DFA
	{
		private const string DFA24_eotS =
			"\x3\xFFFF\x2\x6\x2\xFFFF\x1\x6";
		private const string DFA24_eofS =
			"\x8\xFFFF";
		private const string DFA24_minS =
			"\x1\x2E\x1\x30\x1\x2E\x2\x30\x2\xFFFF\x1\x30";
		private const string DFA24_maxS =
			"\x2\x39\x3\x65\x2\xFFFF\x1\x65";
		private const string DFA24_acceptS =
			"\x5\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA24_specialS =
			"\x8\xFFFF}>";
		private static readonly string[] DFA24_transitionS =
			{
				"\x1\x1\x1\xFFFF\xA\x2",
				"\xA\x3",
				"\x1\x4\x1\xFFFF\xA\x2\xB\xFFFF\x1\x5\x1F\xFFFF\x1\x5",
				"\xA\x3\xB\xFFFF\x1\x5\x1F\xFFFF\x1\x5",
				"\xA\x7\xB\xFFFF\x1\x5\x1F\xFFFF\x1\x5",
				"",
				"",
				"\xA\x7\xB\xFFFF\x1\x5\x1F\xFFFF\x1\x5"
			};

		private static readonly short[] DFA24_eot = DFA.UnpackEncodedString(DFA24_eotS);
		private static readonly short[] DFA24_eof = DFA.UnpackEncodedString(DFA24_eofS);
		private static readonly char[] DFA24_min = DFA.UnpackEncodedStringToUnsignedChars(DFA24_minS);
		private static readonly char[] DFA24_max = DFA.UnpackEncodedStringToUnsignedChars(DFA24_maxS);
		private static readonly short[] DFA24_accept = DFA.UnpackEncodedString(DFA24_acceptS);
		private static readonly short[] DFA24_special = DFA.UnpackEncodedString(DFA24_specialS);
		private static readonly short[][] DFA24_transition;

		static DFA24()
		{
			int numStates = DFA24_transitionS.Length;
			DFA24_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA24_transition[i] = DFA.UnpackEncodedString(DFA24_transitionS[i]);
			}
		}

		public DFA24( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 24;
			this.eot = DFA24_eot;
			this.eof = DFA24_eof;
			this.min = DFA24_min;
			this.max = DFA24_max;
			this.accept = DFA24_accept;
			this.special = DFA24_special;
			this.transition = DFA24_transition;
		}

		public override string Description { get { return "548:1: Real : ( DNum | Exponent_DNum );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA36 : DFA
	{
		private const string DFA36_eotS =
			"\x1\x34\x1\x31\x1\x3B\x1\x3E\x1\x3F\x1\x40\x2\x31\x1\x47\x4\xFFFF\x1"+
			"\x31\x1\xFFFF\x1\x4A\x2\x31\x1\x55\x2\x31\x1\x5C\x1\x31\x1\x5F\x1\x31"+
			"\x3\xFFFF\x1\x31\x1\x63\x1\x64\x1\x66\x1\x31\x1\xFFFF\x1\x31\x2\xFFFF"+
			"\x3\x31\x1\xFFFF\x2\x31\x2\x6F\x1\x31\x2\xFFFF\x1\x74\x2\xFFFF\x1\x74"+
			"\x1\xFFFF\x2\x31\x1\x78\x2\x31\x7\xFFFF\x5\x31\x2\xFFFF\x1\x31\x1\x82"+
			"\x2\xFFFF\x7\x31\x3\xFFFF\x1\x31\x1\x8B\x2\x31\x3\xFFFF\x1\x31\x2\xFFFF"+
			"\x1\x31\x1\x92\x1\x31\x4\xFFFF\x8\x31\x1\xFFFF\x2\x6F\x1\x31\x1\xA1\x1"+
			"\xFFFF\x1\xA1\x1\x31\x1\xA3\x1\xFFFF\x9\x31\x1\xFFFF\x3\x31\x1\xB2\x4"+
			"\x31\x1\xFFFF\x2\x31\x1\xBA\x2\x31\x1\xBD\x1\xFFFF\x6\x31\x1\xC4\x1\x31"+
			"\x1\xC6\x4\x31\x2\xFFFF\x1\x31\x1\xFFFF\x3\x31\x1\xBA\x1\xCF\x5\x31\x1"+
			"\xD5\x1\xD7\x2\x31\x1\xFFFF\x7\x31\x1\xFFFF\x1\x31\x1\xE2\x1\xFFFF\x6"+
			"\x31\x1\xFFFF\x1\x31\x1\xFFFF\x3\x31\x1\xED\x1\x31\x2\xEF\x1\xF0\x1\xFFFF"+
			"\x1\xF1\x1\xF2\x1\xF3\x2\x31\x1\xFFFF\x1\x31\x1\xFFFF\x3\x31\x1\xBA\x1"+
			"\xED\x5\x31\x1\xFFFF\x6\x31\x1\x105\x3\x31\x1\xFFFF\x1\x31\x5\xFFFF\x2"+
			"\x31\x1\x10C\x3\x31\x1\x110\x4\x31\x1\xBA\x1\x115\x1\x31\x1\x117\x1\xBA"+
			"\x1\x118\x1\xFFFF\x1\x119\x4\x31\x1\x11E\x1\xFFFF\x1\x11F\x1\x120\x1"+
			"\x31\x1\xFFFF\x3\x31\x1\x126\x1\xFFFF\x1\x126\x3\xFFFF\x1\x119\x1\x31"+
			"\x1\x129\x1\x12A\x3\xFFFF\x1\x12B\x4\x31\x1\xFFFF\x2\x31\x3\xFFFF\x2"+
			"\x31\x1\x134\x2\x31\x1\x119\x1\x137\x1\x138\x1\xFFFF\x2\x31\x2\xFFFF"+
			"\x2\x31\x2\x126";
		private const string DFA36_eofS =
			"\x13D\xFFFF";
		private const string DFA36_minS =
			"\x1\x21\x1\x52\x1\x26\x3\x3D\x1\x6F\x1\x61\x1\x3A\x4\xFFFF\x1\x65\x1"+
			"\xFFFF\x1\x30\x1\x63\x1\x61\x1\x2A\x1\x6C\x1\x66\x1\x2D\x1\x69\x1\x3D"+
			"\x1\x65\x3\xFFFF\x1\x62\x1\x3D\x1\x2B\x1\x3E\x1\x65\x1\xFFFF\x1\x74\x2"+
			"\xFFFF\x1\x61\x1\x68\x1\x6F\x1\xFFFF\x1\x52\x1\x72\x2\x2E\x1\x72\x2\xFFFF"+
			"\x1\x3C\x2\xFFFF\x1\x3E\x1\xFFFF\x1\x73\x1\x64\x1\x30\x2\x52\x7\xFFFF"+
			"\x1\x65\x1\x6F\x1\x73\x1\x61\x1\x6E\x2\xFFFF\x1\x66\x1\x30\x2\xFFFF\x1"+
			"\x68\x1\x73\x1\x74\x1\x72\x1\x6E\x1\x6F\x1\x6C\x3\xFFFF\x1\x6F\x1\x30"+
			"\x1\x70\x1\x63\x3\xFFFF\x1\x73\x2\xFFFF\x1\x77\x1\x30\x1\x6A\x4\xFFFF"+
			"\x1\x71\x1\x61\x1\x69\x1\x72\x1\x69\x1\x72\x1\x62\x1\x69\x1\xFFFF\x2"+
			"\x2E\x1\x75\x1\x3C\x1\xFFFF\x1\x3D\x1\x74\x1\x30\x1\xFFFF\x2\x41\x1\x61"+
			"\x1\x6C\x1\x65\x1\x73\x1\x6E\x1\x73\x1\x61\x1\xFFFF\x1\x6F\x2\x65\x1"+
			"\x30\x1\x63\x1\x61\x1\x73\x1\x62\x1\xFFFF\x1\x6C\x1\x74\x1\x30\x1\x6C"+
			"\x1\x74\x1\x30\x1\xFFFF\x1\x65\x2\x75\x1\x74\x1\x69\x1\x74\x1\x30\x1"+
			"\x6C\x1\x30\x1\x6C\x1\x76\x1\x74\x1\x65\x2\xFFFF\x1\x72\x1\xFFFF\x2\x59"+
			"\x1\x6B\x2\x30\x1\x73\x1\x65\x1\x74\x1\x69\x1\x75\x2\x30\x1\x6E\x1\x61"+
			"\x1\xFFFF\x2\x74\x1\x65\x1\x61\x1\x65\x1\x61\x1\x72\x1\xFFFF\x1\x75\x1"+
			"\x30\x1\xFFFF\x1\x63\x1\x72\x2\x69\x1\x6E\x1\x63\x1\xFFFF\x1\x65\x1\xFFFF"+
			"\x1\x69\x1\x61\x1\x65\x1\x30\x1\x61\x3\x30\x1\xFFFF\x3\x30\x1\x6E\x1"+
			"\x6C\x1\xFFFF\x1\x66\x1\xFFFF\x1\x64\x1\x63\x1\x69\x2\x30\x1\x6C\x1\x6D"+
			"\x1\x6E\x1\x66\x1\x64\x1\xFFFF\x1\x74\x1\x6E\x1\x72\x1\x63\x1\x67\x1"+
			"\x68\x1\x30\x1\x63\x1\x74\x1\x63\x1\xFFFF\x1\x63\x5\xFFFF\x1\x75\x1\x74"+
			"\x1\x30\x1\x73\x1\x68\x1\x6F\x1\x30\x1\x65\x1\x63\x1\x61\x1\x65\x2\x30"+
			"\x1\x65\x3\x30\x1\xFFFF\x1\x30\x1\x65\x2\x74\x1\x65\x1\x30\x1\xFFFF\x2"+
			"\x30\x1\x6E\x1\xFFFF\x1\x6E\x1\x65\x1\x63\x1\x30\x1\xFFFF\x1\x30\x3\xFFFF"+
			"\x1\x30\x1\x65\x2\x30\x3\xFFFF\x1\x30\x1\x74\x1\x6F\x1\x65\x1\x6F\x1"+
			"\xFFFF\x1\x6F\x1\x64\x3\xFFFF\x1\x73\x1\x66\x1\x30\x2\x6E\x3\x30\x1\xFFFF"+
			"\x2\x63\x2\xFFFF\x2\x65\x2\x30";
		private const string DFA36_maxS =
			"\x1\x7E\x1\x73\x1\x3D\x1\x3E\x2\x3D\x1\x72\x1\x6F\x1\x3A\x4\xFFFF\x1"+
			"\x6F\x1\xFFFF\x1\x3D\x1\x78\x1\x75\x1\x3D\x1\x6C\x1\x6E\x1\x3E\x1\x69"+
			"\x1\x7C\x1\x65\x3\xFFFF\x1\x72\x2\x3D\x1\x3E\x1\x65\x1\xFFFF\x1\x77\x2"+
			"\xFFFF\x1\x61\x1\x68\x1\x6F\x1\xFFFF\x1\x72\x1\x75\x2\x65\x1\x72\x2\xFFFF"+
			"\x1\x3C\x2\xFFFF\x1\x3E\x1\xFFFF\x1\x73\x1\x64\x1\x7A\x2\x72\x7\xFFFF"+
			"\x1\x65\x1\x6F\x1\x73\x1\x6F\x1\x6E\x2\xFFFF\x1\x66\x1\x7A\x2\xFFFF\x1"+
			"\x68\x1\x73\x1\x74\x1\x72\x1\x6E\x1\x6F\x1\x6C\x3\xFFFF\x1\x6F\x1\x7A"+
			"\x1\x70\x1\x74\x3\xFFFF\x1\x73\x2\xFFFF\x1\x77\x1\x7A\x1\x6A\x4\xFFFF"+
			"\x1\x74\x1\x72\x1\x69\x1\x72\x1\x69\x1\x72\x1\x62\x1\x6F\x1\xFFFF\x2"+
			"\x65\x1\x75\x1\x3D\x1\xFFFF\x1\x3D\x1\x74\x1\x7A\x1\xFFFF\x3\x61\x1\x6C"+
			"\x1\x65\x1\x73\x1\x6E\x1\x74\x1\x61\x1\xFFFF\x1\x6F\x2\x65\x1\x7A\x1"+
			"\x63\x1\x61\x1\x73\x1\x62\x1\xFFFF\x1\x6C\x1\x74\x1\x7A\x1\x6C\x1\x74"+
			"\x1\x7A\x1\xFFFF\x1\x65\x2\x75\x1\x74\x1\x69\x1\x74\x1\x7A\x1\x6C\x1"+
			"\x7A\x1\x6C\x1\x76\x1\x74\x1\x65\x2\xFFFF\x1\x72\x1\xFFFF\x2\x79\x1\x6B"+
			"\x2\x7A\x1\x73\x1\x65\x1\x74\x1\x69\x1\x75\x2\x7A\x1\x6E\x1\x61\x1\xFFFF"+
			"\x2\x74\x1\x65\x1\x61\x1\x65\x1\x61\x1\x72\x1\xFFFF\x1\x75\x1\x7A\x1"+
			"\xFFFF\x1\x63\x1\x72\x2\x69\x1\x6E\x1\x63\x1\xFFFF\x1\x65\x1\xFFFF\x1"+
			"\x69\x1\x61\x1\x65\x1\x7A\x1\x61\x3\x7A\x1\xFFFF\x3\x7A\x1\x6E\x1\x6C"+
			"\x1\xFFFF\x1\x66\x1\xFFFF\x1\x64\x1\x63\x1\x69\x2\x7A\x1\x6C\x1\x6D\x1"+
			"\x6E\x1\x66\x1\x64\x1\xFFFF\x1\x74\x1\x6E\x1\x72\x1\x63\x1\x67\x1\x68"+
			"\x1\x7A\x1\x63\x1\x74\x1\x63\x1\xFFFF\x1\x63\x5\xFFFF\x1\x75\x1\x74\x1"+
			"\x7A\x1\x73\x1\x68\x1\x6F\x1\x7A\x1\x65\x1\x63\x1\x61\x1\x65\x2\x7A\x1"+
			"\x65\x3\x7A\x1\xFFFF\x1\x7A\x1\x65\x2\x74\x1\x65\x1\x7A\x1\xFFFF\x2\x7A"+
			"\x1\x6E\x1\xFFFF\x1\x6E\x1\x65\x1\x63\x1\x7A\x1\xFFFF\x1\x7A\x3\xFFFF"+
			"\x1\x7A\x1\x65\x2\x7A\x3\xFFFF\x1\x7A\x1\x74\x1\x6F\x1\x65\x1\x6F\x1"+
			"\xFFFF\x1\x6F\x1\x64\x3\xFFFF\x1\x73\x1\x66\x1\x7A\x2\x6E\x3\x7A\x1\xFFFF"+
			"\x2\x63\x2\xFFFF\x2\x65\x2\x7A";
		private const string DFA36_acceptS =
			"\x9\xFFFF\x1\xC\x1\xD\x1\xE\x1\x10\x1\xFFFF\x1\x15\xA\xFFFF\x1\x2B\x1"+
			"\x2C\x1\x2D\x5\xFFFF\x1\x34\x1\xFFFF\x1\x36\x1\x38\x3\xFFFF\x1\x40\x5"+
			"\xFFFF\x1\x48\x1\x49\x1\xFFFF\x1\x4B\x1\x4C\x1\xFFFF\x1\x51\x5\xFFFF"+
			"\x1\x27\x1\x2\x1\x4\x1\x4D\x1\x1A\x1\x5\x1\x6\x5\xFFFF\x1\xA\x1\xF\x2"+
			"\xFFFF\x1\x16\x1\x46\x7\xFFFF\x1\x3E\x1\x3F\x1\x1E\x4\xFFFF\x1\x23\x1"+
			"\x50\x1\x29\x1\xFFFF\x1\x28\x1\x30\x3\xFFFF\x1\x2F\x1\x31\x1\x3D\x1\x32"+
			"\x8\xFFFF\x1\x45\x4\xFFFF\x1\x4E\x3\xFFFF\x1\x3C\x9\xFFFF\x1\x14\x8\xFFFF"+
			"\x1\x21\x6\xFFFF\x1\x2E\xD\xFFFF\x1\x4A\x1\x4F\x1\xFFFF\x1\x3\xE\xFFFF"+
			"\x1\x1C\x7\xFFFF\x1\x43\x2\xFFFF\x1\x2A\x6\xFFFF\x1\x39\x1\xFFFF\x1\x3B"+
			"\x8\xFFFF\x1\x8\x5\xFFFF\x1\x17\x1\xFFFF\x1\x18\xA\xFFFF\x1\x26\xA\xFFFF"+
			"\x1\x47\x1\xFFFF\x1\x41\x1\x7\x1\x9\x1\xB\x1\x11\x11\xFFFF\x1\x3A\x6"+
			"\xFFFF\x1\x19\x3\xFFFF\x1\x20\x4\xFFFF\x1\x33\x1\xFFFF\x1\x35\x1\x37"+
			"\x1\x44\x4\xFFFF\x1\x13\x1\x1B\x1\x1D\x5\xFFFF\x1\x42\x2\xFFFF\x1\x1"+
			"\x1\x12\x1\x1F\x8\xFFFF\x1\x25\x2\xFFFF\x1\x22\x1\x24\x4\xFFFF";
		private const string DFA36_specialS =
			"\x13D\xFFFF}>";
		private static readonly string[] DFA36_transitionS =
			{
				"\x1\x5\x1\x2F\x1\x28\x1\xE\x1\x1D\x1\x2\x1\x2E\x1\x1A\x1\xA\x1\x4\x1"+
				"\x1E\x1\xC\x1\x15\x1\xF\x1\x12\x1\x2B\x9\x2C\x1\x8\x1\x21\x1\x30\x1"+
				"\x3\x1\x33\x1\x1F\x1\x23\x1\x29\x19\x31\x1\x1B\x1\xFFFF\x1\xB\x1\x32"+
				"\x1\x31\x1\xFFFF\x1\x1\x1\x6\x1\x7\x1\xD\x1\x10\x1\x11\x1\x13\x1\x31"+
				"\x1\x14\x2\x31\x1\x16\x1\x31\x1\x18\x1\x1C\x1\x2A\x1\x31\x1\x20\x1\x22"+
				"\x1\x2D\x1\x31\x1\x25\x1\x26\x1\x27\x2\x31\x1\x19\x1\x17\x1\x9\x1\x24",
				"\x1\x39\xF\xFFFF\x1\x35\xB\xFFFF\x1\x36\x3\xFFFF\x1\x38\x1\x37",
				"\x1\x3A\x16\xFFFF\x1\x32",
				"\x1\x3D\x1\x3C",
				"\x1\x32",
				"\x1\x3D",
				"\x1\x42\x2\xFFFF\x1\x41",
				"\x1\x43\xA\xFFFF\x1\x44\x2\xFFFF\x1\x45",
				"\x1\x46",
				"",
				"",
				"",
				"",
				"\x1\x48\x9\xFFFF\x1\x49",
				"",
				"\xA\x4B\x3\xFFFF\x1\x32",
				"\x1\x4C\x8\xFFFF\x1\x4D\xB\xFFFF\x1\x4E",
				"\x1\x52\xA\xFFFF\x1\x51\x2\xFFFF\x1\x4F\x5\xFFFF\x1\x50",
				"\x1\x53\x4\xFFFF\x1\x54\xD\xFFFF\x1\x32",
				"\x1\x56",
				"\x1\x57\x6\xFFFF\x1\x58\x1\x59",
				"\x1\x5B\xF\xFFFF\x1\x32\x1\x5A",
				"\x1\x5D",
				"\x1\x32\x3E\xFFFF\x1\x5E",
				"\x1\x60",
				"",
				"",
				"",
				"\x1\x62\xF\xFFFF\x1\x61",
				"\x1\x32",
				"\x1\x5B\x11\xFFFF\x1\x32",
				"\x1\x65",
				"\x1\x67",
				"",
				"\x1\x68\x2\xFFFF\x1\x69",
				"",
				"",
				"\x1\x6A",
				"\x1\x6B",
				"\x1\x6C",
				"",
				"\x1\x39\x1F\xFFFF\x1\x39",
				"\x1\x6E\x2\xFFFF\x1\x6D",
				"\x1\x4B\x1\xFFFF\x8\x70\x2\x4B\xB\xFFFF\x1\x4B\x1F\xFFFF\x1\x4B",
				"\x1\x4B\x1\xFFFF\xA\x71\xB\xFFFF\x1\x4B\x1F\xFFFF\x1\x4B",
				"\x1\x72",
				"",
				"",
				"\x1\x73",
				"",
				"",
				"\x1\x75",
				"",
				"\x1\x76",
				"\x1\x77",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x7A\x1F\xFFFF\x1\x79",
				"\x1\x7A\x1F\xFFFF\x1\x7A",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x7B",
				"\x1\x7C",
				"\x1\x7D",
				"\x1\x7E\xD\xFFFF\x1\x7F",
				"\x1\x80",
				"",
				"",
				"\x1\x81",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"",
				"\x1\x83",
				"\x1\x84",
				"\x1\x85",
				"\x1\x86",
				"\x1\x87",
				"\x1\x88",
				"\x1\x89",
				"",
				"",
				"",
				"\x1\x8A",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x8C",
				"\x1\x8F\xF\xFFFF\x1\x8D\x1\x8E",
				"",
				"",
				"",
				"\x1\x90",
				"",
				"",
				"\x1\x91",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x93",
				"",
				"",
				"",
				"",
				"\x1\x95\x2\xFFFF\x1\x94",
				"\x1\x96\x10\xFFFF\x1\x97",
				"\x1\x98",
				"\x1\x99",
				"\x1\x9A",
				"\x1\x9B",
				"\x1\x9C",
				"\x1\x9D\x5\xFFFF\x1\x9E",
				"",
				"\x1\x4B\x1\xFFFF\x8\x70\x2\x4B\xB\xFFFF\x1\x4B\x1F\xFFFF\x1\x4B",
				"\x1\x4B\x1\xFFFF\xA\x71\xB\xFFFF\x1\x4B\x1F\xFFFF\x1\x4B",
				"\x1\x9F",
				"\x1\xA0\x1\x32",
				"",
				"\x1\x32",
				"\x1\xA2",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"\x1\xA5\x1F\xFFFF\x1\xA4",
				"\x1\xA5\x1F\xFFFF\x1\xA5",
				"\x1\xA6",
				"\x1\xA7",
				"\x1\xA8",
				"\x1\xA9",
				"\x1\xAA",
				"\x1\xAB\x1\xAC",
				"\x1\xAD",
				"",
				"\x1\xAE",
				"\x1\xAF",
				"\x1\xB0",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x4\x31\x1\xB1\x15"+
				"\x31",
				"\x1\xB3",
				"\x1\xB4",
				"\x1\xB5",
				"\x1\xB6",
				"",
				"\x1\xB7",
				"\x1\xB8",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x4\x31\x1\xB9\x15"+
				"\x31",
				"\x1\xBB",
				"\x1\xBC",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"\x1\xBE",
				"\x1\xBF",
				"\x1\xC0",
				"\x1\xC1",
				"\x1\xC2",
				"\x1\xC3",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\xC5",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\xC7",
				"\x1\xC8",
				"\x1\xC9",
				"\x1\xCA",
				"",
				"",
				"\x1\xCB",
				"",
				"\x1\xCD\x1F\xFFFF\x1\xCC",
				"\x1\xCD\x1F\xFFFF\x1\xCD",
				"\x1\xCE",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\xD0",
				"\x1\xD1",
				"\x1\xD2",
				"\x1\xD3",
				"\x1\xD4",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x8\x31\x1\xD6\x11"+
				"\x31",
				"\x1\xD8",
				"\x1\xD9",
				"",
				"\x1\xDA",
				"\x1\xDB",
				"\x1\xDC",
				"\x1\xDD",
				"\x1\xDE",
				"\x1\xDF",
				"\x1\xE0",
				"",
				"\x1\xE1",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"\x1\xE3",
				"\x1\xE4",
				"\x1\xE5",
				"\x1\xE6",
				"\x1\xE7",
				"\x1\xE8",
				"",
				"\x1\xE9",
				"",
				"\x1\xEA",
				"\x1\xEB",
				"\x1\xEC",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\xEE",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\xF4",
				"\x1\xF5",
				"",
				"\x1\xF6",
				"",
				"\x1\xF7",
				"\x1\xF8",
				"\x1\xF9",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\xFA",
				"\x1\xFB",
				"\x1\xFC",
				"\x1\xFD",
				"\x1\xFE",
				"",
				"\x1\xFF",
				"\x1\x100",
				"\x1\x101",
				"\x1\x102",
				"\x1\x103",
				"\x1\x104",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x106",
				"\x1\x107",
				"\x1\x108",
				"",
				"\x1\x109",
				"",
				"",
				"",
				"",
				"",
				"\x1\x10A",
				"\x1\x10B",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x10D",
				"\x1\x10E",
				"\x1\x10F",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x111",
				"\x1\x112",
				"\x1\x113",
				"\x1\x114",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x116",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x11A",
				"\x1\x11B",
				"\x1\x11C",
				"\x1\x11D",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x121",
				"",
				"\x1\x122",
				"\x1\x123",
				"\x1\x124",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x125\x1\xFFFF\x1A\x31",
				"",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x127\x1\xFFFF\x1A\x31",
				"",
				"",
				"",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x128",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"",
				"",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x12C",
				"\x1\x12D",
				"\x1\x12E",
				"\x1\x12F",
				"",
				"\x1\x130",
				"\x1\x131",
				"",
				"",
				"",
				"\x1\x132",
				"\x1\x133",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\x1\x135",
				"\x1\x136",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"",
				"\x1\x139",
				"\x1\x13A",
				"",
				"",
				"\x1\x13B",
				"\x1\x13C",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31",
				"\xA\x31\x7\xFFFF\x1A\x31\x4\xFFFF\x1\x31\x1\xFFFF\x1A\x31"
			};

		private static readonly short[] DFA36_eot = DFA.UnpackEncodedString(DFA36_eotS);
		private static readonly short[] DFA36_eof = DFA.UnpackEncodedString(DFA36_eofS);
		private static readonly char[] DFA36_min = DFA.UnpackEncodedStringToUnsignedChars(DFA36_minS);
		private static readonly char[] DFA36_max = DFA.UnpackEncodedStringToUnsignedChars(DFA36_maxS);
		private static readonly short[] DFA36_accept = DFA.UnpackEncodedString(DFA36_acceptS);
		private static readonly short[] DFA36_special = DFA.UnpackEncodedString(DFA36_specialS);
		private static readonly short[][] DFA36_transition;

		static DFA36()
		{
			int numStates = DFA36_transitionS.Length;
			DFA36_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA36_transition[i] = DFA.UnpackEncodedString(DFA36_transitionS[i]);
			}
		}

		public DFA36( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 36;
			this.eot = DFA36_eot;
			this.eof = DFA36_eof;
			this.min = DFA36_min;
			this.max = DFA36_max;
			this.accept = DFA36_accept;
			this.special = DFA36_special;
			this.transition = DFA36_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( Abstract | Ampersand | And | ArrayAssign | Asterisk | Bang | Break | Case | Class | ClassMember | Clone | CloseCurlyBracket | CloseRoundBracket | CloseSquareBracket | Colon | Comma | Const | Continue | Default | Do | Dollar | Dot | Echo | Else | ElseIf | Equals | Extends | For | Foreach | Forwardslash | Function | Global | If | Implements | InstanceMember | Instanceof | Interface | List | LogicalAnd | LogicalOr | Minus | New | OpenCurlyBracket | OpenRoundBracket | OpenSquareBracket | Or | Percent | Pipe | Plus | QuestionMark | Return | SemiColon | Static | SuppressWarnings | Switch | Tilde | Var | While | Xor | T__113 | BodyString | MultilineComment | SinglelineComment | UnixComment | Array | RequireOperator | PrimitiveType | AccessModifier | Integer | Real | Boolean | SingleQuotedString | DoubleQuotedString | HereDoc | UnquotedString | AsignmentOperator | EqualityOperator | ComparisionOperator | ShiftOperator | IncrementOperator | WhiteSpace );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion

}

} // namespace  Code2Xml.Languages.ANTLRv3.Processors.Php 
